

<!DOCTYPE html>
<html lang="zh-CN" xmlns:v-bind="http://www.w3.org/1999/xhtml">

<head><meta name="generator" content="Hexo 3.9.0">
    <title>你不懂JS（You-Dont-Know-JS）阅读总结 - it&#39;s Me.</title>
<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="author" content="Jacky Leung">
<meta name="description" content="关键概念列表，方便日后复读查询">
<meta name="keywords" content>

    <meta charset="utf-8">
    <meta name="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta content="telephone=no" name="format-detection">
    <meta name="renderer" content="webkit">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/journal.css?60901118">

<script src="/js/loadCSS.js"></script>
<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons");
    (function (d) {
        var config = {
                kitId: 'dwg1tuc',
                scriptTimeout: 3000,
                async: true
            },
            h = d.documentElement, t = setTimeout(function () {
                h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
            }, config.scriptTimeout), tk = d.createElement("script"), f = false,
            s = d.getElementsByTagName("script")[0], a;
        h.className += " wf-loading";
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
            a = this.readyState;
            if (f || a && a != "complete" && a != "loaded") return;
            f = true;
            clearTimeout(t);
            try {
                Typekit.load(config)
            } catch (e) {
            }
        };
        s.parentNode.insertBefore(tk, s)
    })(document);
</script>
<noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons">
</noscript>
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>
<body>
<div id="top"></div>
<div id="app">
<div class="single-column-drawer-container" ref="drawer" v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            <a class="a-block drawer-menu-item false" href="http://yoursite.com">
                首页
            </a>
            
            <a class="a-block drawer-menu-item false" href="/archives">
                归档
            </a>
            

            
            
            <a class="a-block drawer-menu-item false" href="/categories/index.html">
                分类
            </a>
            
            <a class="a-block drawer-menu-item false" href="/tags/index.html">
                标签
            </a>
            

            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="/">
            it&#39;s Me.
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead" v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="/">
        <div class="single-column-header-title">it&#39;s Me.</div>
        <div class="single-column-header-subtitle"></div>
    </a>
</div>
<div ref="sideContainer" class="side-container">
    <a class="a-block nav-head false" href="/">
        <div class="nav-title">
            it's Me.
        </div>
        <div class="nav-subtitle">
            畅游乾坤<br>天意人心
        </div>
    </a>

    <div class="nav-link-list">
        
        <a class="a-block no-tint nav-link-item false" href="/archives">
            归档
        </a>
        

        
        
        <a class="a-block nav-link-item false" href="/categories/index.html">
            分类
        </a>
        
        <a class="a-block nav-link-item false" href="/tags/index.html">
            标签
        </a>
        

        
    </div>

    
    <div class="nav-footer">
        <!-- Proudly published with Hexo<br>
        
        Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
        
        &copy; 2019 <a href="http://yoursite.com">it&#39;s Me.</a> -->
    </div>
</div>
<div ref="extraContainer" class="extra-container">
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>

        
    </div>
</div>



<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            <div class="post-head-wrapper" style="background-image: url('/2019/05/08/你不懂JS（You-Dont-Know-JS）阅读总结/cover.jpg')">
                <div class="post-title">
                    你不懂JS（You-Dont-Know-JS）阅读总结
                    <div class="post-meta">
                        <time datetime="2019-05-08T08:04:23.000Z" itemprop="datePublished">
                            2019-05-08 16:04
                        </time>&nbsp;
                        
                        
                        <i class="material-icons" style>folder</i>
                        
                        <a href="/categories/读书/">读书</a>
                        
                        
    
                        
                        
                        <i class="material-icons" style>label</i>
                        
                        <a href="/tags/Javascript/">Javascript</a>
                        
                        
                    </div>
                </div>
            </div>
    
            <div class="post-body-wrapper">
                <div class="post-body">
                    <blockquote>
<p>本文作为阅读【你不懂JS（You-Dont-Know-JS）】系列丛书的笔记总结，持续更新内容。旨在每章的关键概念，方便日后翻查。</p>
</blockquote>
<h3 id="你不懂JS：作用域与闭包"><a href="#你不懂JS：作用域与闭包" class="headerlink" title="你不懂JS：作用域与闭包"></a><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/README.md#you-dont-know-js-scope--closures" target="_blank" rel="noopener">你不懂JS：作用域与闭包</a></h3><blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch1.md" target="_blank" rel="noopener">第一章：什么是作用域？</a></p>
</blockquote>
<ul>
<li>编译器理论：尽管 JavaScript 一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言。<ul>
<li>分词：将一连串字符打断成（对于语言来说）有意义的片段，称为 token（记号）。</li>
<li>解析：将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为“抽象语法树”（AST —— Abstract Syntax Tree）。</li>
<li>代码生成：这个处理将抽象语法树转换为可执行的代码。</li>
</ul>
</li>
<li>引擎：<ul>
<li>LHS(赋值)：引擎 在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个 全局作用域 将会在 全局作用域中 创建一个同名的新变量，并把它交还给 引擎。</li>
<li>RHS(取值)：如果 RHS 查询在嵌套的 作用域 的任何地方都找不到一个值，这会导致 引擎 抛出一个 ReferenceError。</li>
<li>嵌套作用域：遍历嵌套 作用域 的简单规则：引擎 从当前执行的 作用域 开始，在那里查找变量，如果没有找到，就向上走一级继续查找，如此类推。如果到了最外层的全局作用域，那么查找就会停止，无论它是否找到了变量。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch2.md" target="_blank" rel="noopener">第二章：词法作用域</a></p>
</blockquote>
<ul>
<li>词法作用域：词法作用域是在词法分析时被定义的作用域。换句话说，词法作用域是基于，你，在写程序时，变量和作用域的块儿在何处被编写决定的，因此它在词法分析器处理你的代码时（基本上）是固定不变的。</li>
<li>词法分析时：词法作用域是基于，你，在写程序时，变量和作用域的块儿在何处被编写决定的，因此它在词法分析器处理你的代码时（基本上）是固定不变的。</li>
<li>查找：一旦找到第一个匹配，作用域查询就停止了。</li>
<li>欺骗词法作用域：eval(..) 和 with 都受Strict模式的影响（制约）。with 干脆就不允许使用，而虽然 eval(..) 还保有其核心功能，但各种间接形式的或不安全的 eval(..) 是不允许的。<ul>
<li>eval: 动态生成的函数的代码。 with: 将这个对象视为好像它是一个完全隔离的词法作用域。<ul>
<li>性能：JavaScript 引擎 在编译阶段期行许多性能优化工作。其中的一些优化原理都归结为实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明都在什么位置，这样在执行期间就可以少花些力气来解析标识符。无论 引擎 将在努力限制这些悲观臆测的副作用上表现得多么聪明，都没有任何办法可以绕过这个事实：没有优化，代码就运行的更慢。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch3.md" target="_blank" rel="noopener">第三章：函数与块儿作用域</a></p>
</blockquote>
<ul>
<li>函数中的作用域：<ul>
<li>隐藏于普通作用域。</li>
<li>避免冲突。</li>
<li>模块管理。</li>
</ul>
</li>
<li>函数作为作用域：<ul>
<li>匿名与命名：总是命名你的函数表达式。</li>
<li>立即调用函数表达式。</li>
</ul>
</li>
<li>块儿作为作用域：<ul>
<li>try/catch：一个鲜为人知的事实是，JavaScript 在 ES3 中明确指出在 try/catch 的 catch 子句中声明的变量，是属于 catch 块儿的块儿作用域的。</li>
<li>let：我们可以在一个语句是合法文法的任何地方，通过简单地引入一个 { .. } 来为 let 创建一个任意的可以绑定的块儿。</li>
<li>垃圾回收：块儿作用域的另一个有用之处是关于闭包和释放内存的垃圾回收。</li>
<li>const：任何稍后改变它的企图都将导致错误。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch4.md" target="_blank" rel="noopener">第四章：提升</a></p>
</blockquote>
<ul>
<li>编译器：<ul>
<li>引擎：实际上将会在它解释执行你的 JavaScript 代码之前编译它。编译过程的一部分就是找到所有的声明，并将它们关联在合适的作用域上。</li>
<li>提升：是以作用域为单位的 只有声明本身被提升了，而任何赋值或者其他的执行逻辑都被留在 原处。</li>
</ul>
</li>
<li>函数优先：<ul>
<li>函数声明 &gt; 变量声明：都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，函数会首先被提升，然后才是变量。</li>
<li>避免在块儿中声明函数可能是最好的做法。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch5.md" target="_blank" rel="noopener">第五章：作用域闭包</a></p>
</blockquote>
<ul>
<li>闭包：<ul>
<li>在 JavaScript 中闭包无所不在，你只是必须认出它并接纳它。</li>
<li>闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。</li>
</ul>
</li>
<li>模块：<ul>
<li>通过在模块实例内部持有一个指向公有API对象的内部引用，你可以 从内部 修改这个模块，包括添加和删除方法，属性，和 改变它们的值。</li>
<li>现代的模块：调用一个函数定义包装器，并将它的返回值作为这个模块的API保存下来。</li>
<li>未来的模块：ES6 模块 没有 “内联”格式，它们必须被定义在一个分离的文件中（每个模块一个）。浏览器/引擎拥有一个默认的“模块加载器”（它是可以被覆盖的，但是这超出我们在此讨论的范围），它在模块被导入时同步地加载模块文件。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/README.md#you-dont-know-js-scope--closures" target="_blank" rel="noopener">附录</a></p>
</blockquote>
<ul>
<li><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/apA.md" target="_blank" rel="noopener">附录A：动态作用域</a>：<ul>
<li>要清楚，JavaScript 实际上没有动态作用域。它拥有词法作用域。就这么简单。但是 this 机制有些像动态作用域。</li>
<li>关键的差异：词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是 函数在何处被声明，但是动态作用域关心的是函数 从何处 被调用。</li>
</ul>
</li>
<li><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/apB.md" target="_blank" rel="noopener">附录B：填补块儿作用域</a>：<ul>
<li>try/catch：catch 子句拥有块儿作用域。</li>
<li>隐含的与明确的块儿：你可以使用更好的和更明确的 let 语句形式，即便它（还）不是任何 ES 官方版本的一部分。</li>
<li>性能：你是否想要使用块儿作用域。如果是，这些工具给你提供了这些选择。如果不，那就在你的代码中继续使用 var。</li>
</ul>
</li>
<li><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/apC.md" target="_blank" rel="noopener">附录C：词法this</a>：<ul>
<li>箭头函数：采用它们的直接外围词法作用域的 this 的值，无论它是什么。</li>
<li>正确地使用并接受this机制：不管你是偏好箭头函数的新的词法 this 行为，还是偏好经得起考验的 bind()，重要的是要注意箭头函数 不 仅仅是关于可以少打一些“function”。</li>
</ul>
</li>
<li><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/apD.md" target="_blank" rel="noopener">附录D: 鸣谢</a>：<ul>
<li>但愿这部丛书被我们所有人“拥有”，并为增进对 JavaScript 语言的意识和理解做出贡献，成为当下和未来所有社区贡献者的助益。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="你不懂JS-this-与对象原型"><a href="#你不懂JS-this-与对象原型" class="headerlink" title="你不懂JS: this 与对象原型"></a><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes" target="_blank" rel="noopener">你不懂JS: this 与对象原型</a></h3><blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch1.md" target="_blank" rel="noopener">第一章: this 是什么？</a></p>
</blockquote>
<ul>
<li>为什么要用 this？：<ul>
<li>将执行环境作为一个明确参数传递，通常比传递 this 执行环境要乱。当我们探索对象和原型时，你将会看到一组可以自动引用恰当执行环境对象的函数是多么有用。</li>
</ul>
</li>
<li>它的作用域：<ul>
<li>this 不会以任何方式指向函数的 词法作用域。</li>
<li>this 不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。this 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch2.md" target="_blank" rel="noopener">第二章: this 豁然开朗！</a></p>
</blockquote>
<ul>
<li>调用点（Call-site）和 调用栈（call-stack）：<ul>
<li>调用点：函数在代码中被调用的位置（不是被声明的位置）。</li>
<li>调用栈：使我们到达当前执行位置而被调用的所有方法的堆栈。</li>
</ul>
</li>
<li>绑定规则：this 绑定规则都是完全基于调用点的<ul>
<li>默认绑定（Default Binding）：独立函数调用。可以认为这种 this 规则是在没有其他规则适用时的默认规则。（默认绑定来说 全局对象（window/global） 是唯一合法的。strict mode下 this 将被设置为 undefined）。</li>
<li>隐含绑定（Implicit Binding）：调用点是否有一个环境对象（context object）。对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用。<ul>
<li>隐含丢失（Implicitly Lost）：在赋值给一个变量或传参，隐含绑定丢失了它的绑定，这通常意味着它会退回到 默认绑定， 根据 strict mode 的状态，其结果不是全局对象就是 undefined。</li>
</ul>
</li>
<li>明确绑定（Explicit Binding）：函数拥有 call(..) 和 apply(..) 方法。它们接收的第一个参数都是一个用于 this 的对象，之后使用这个指定的 this 来调用函数。因为你已经直接指明你想让 this 是什么。<ul>
<li>硬绑定（Hard Binding）：bind(..) 返回一个硬编码的新函数，它使用你指定的 this 环境来调用原本的函数。</li>
<li>API 调用的“环境”：许多库中的函数，和许多在 JavaScript 语言以及宿主环境中的内建函数，都提供一个可选参数，通常称为“环境（context）”，这种设计作为一种替代方案来确保你的回调函数使用特定的 this 而不必非得使用 bind(..)。从内部来说，几乎可以确定这种类型的函数是通过 call(..) 或 apply(..) 来使用 明确绑定 以节省你的麻烦。</li>
</ul>
</li>
<li>new 绑定（new Binding）：构建了一个新的对象并把这个新对象作为 foo(..) 调用的 this。</li>
</ul>
</li>
<li>判定 this：<ol>
<li>函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。</li>
<li>函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。</li>
<li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。</li>
<li>否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。</li>
</ol>
</li>
<li>this特例：<ul>
<li>被忽略的this：如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</li>
<li>更安全的this：为了 this 而传递一个特殊创建好的对象，这个对象保证不会对你的程序产生副作用。创建 完全为空的对象 的最简单方法就是 Object.create(null)，Object.create(null) 和 {} 很相似，但是没有指向 Object.prototype 的委托，所以它比 {} “空得更彻底”。</li>
<li>间接引用（indirect reference）：(p.foo = o.foo)()，赋值表达式 p.foo = o.foo 的 结果值 是一个刚好指向底层函数对象的引用。如此，起作用的调用点就是 foo()，而非你期待的 p.foo() 或 o.foo()。根据上面的规则，默认绑定 适用。</li>
<li>软化绑定（Softening Binding）：为 默认绑定 提供不同的默认值（不是 global 或 undefined），同时保持函数可以通过 隐含绑定 或 明确绑定 技术来手动绑定 this。</li>
</ul>
</li>
<li>词法 this：<ul>
<li>箭头函数（arrow-function）：不是通过 function 关键字声明的，而是通过所谓的“大箭头”操作符：=&gt;。与使用四种标准的 this 规则不同的是，箭头函数从封闭它的（函数或全局）作用域采用 this 绑定。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch3.md" target="_blank" rel="noopener">第三章：对象</a></p>
</blockquote>
<ul>
<li>类型：<ul>
<li>简单基本类型：string、number、boolean、null、和 undefined 自身 不是 object。null 有时会被当成一个对象类型，但是这种误解源自于一个语言中的 Bug，它使得 typeof null 错误地（而且令人困惑地）返回字符串 “object”。实际上，null 是它自己的基本类型。</li>
<li>复杂基本类型：<ul>
<li>function：是对象的一种子类型（技术上讲，叫做“可调用对象”）。函数在 JS 中被称为“头等（first class）”类型，是因为它们基本上就是普通的对象（附带有可调用的行为语义），而且它们可以像其他普通的对象那样被处理。</li>
<li>array：数组也是一种形式的对象，带有特别的行为。数组在内容的组织上要稍稍比一般的对象更加结构化。</li>
</ul>
</li>
</ul>
</li>
<li>内建对象：String、Number、Boolean、Object、Function、Array、Date、RegExp、Error。<ul>
<li>有字面量和对象：String、Number、Boolean。（如：必要的时候语言会自动地将 “string” 基本类型强制转换为 String 对象类型，这意味着你几乎从不需要明确地创建对象。）</li>
<li>都是对象：无论使用字面还是构造形式，Object、Array、Function、RegExp。</li>
<li>只能构造形式：Date。</li>
<li>Error：Error 对象很少在代码中明示地被创建，它们通常在抛出异常时自动地被创建。</li>
</ul>
</li>
<li>内容：对象的内容由存储在特定命名的 位置 上的（任意类型的）值组成，我们称这些值为属性。<ul>
<li>属性名： 总是 字符串。如果你使用 string 以外的（基本）类型值，它会首先被转换为字符串。这甚至包括在数组中常用于索引的数字，所以要小心不要将对象和数组使用的数字搞混了。</li>
</ul>
</li>
<li>属性（Property） vs. 方法（Method）：<ul>
<li>从技术上讲，函数绝不会“属于”对象。</li>
<li>就算你声明一个函数表达式作为字面对象的一部分，那个函数都不会魔法般地 属于 这个对象 —— 仍然仅仅是同一个函数对象的多个引用罢了。</li>
</ul>
</li>
<li>数组：<ul>
<li>注意，添加命名属性（不论是使用 . 还是 [ ] 操作符语法）不会改变数组的 length 所报告的值。</li>
<li>如果你试图在一个数组上添加属性，但是属性名 看起来 像一个数字，那么最终它会成为一个数字索引。</li>
</ul>
</li>
<li>复制对象：<ul>
<li>一个解决方案是，JSON 安全的对象可以简单地这样 复制：：var newObj = JSON.parse( JSON.stringify( someObj ) )。</li>
<li>浅拷贝：相当易懂，而且没有那么多问题，所以 ES6 为此任务已经定义了 Object.assign(..)。在 Object.assign(..) 中发生的复制是单纯的 = 式赋值，所以任何在源对象属性的特殊性质（比如 writable）在目标对象上 都不会保留 。</li>
</ul>
</li>
<li>属性描述符：<ul>
<li>Object.getOwnPropertyDescriptor：返回 { value、writable、enumerable、configurable }。</li>
<li>Object.defineProperty：添加新属性，或使用期望的性质来修改既存的属性（如果它是 configurable 的！）。<ul>
<li>可写性（Writable）：writable 控制着你改变属性值的能力。（如果writable是false，strict mode会得到一个错误TypeError）<ul>
<li>简单地说，你可以观察到 writable:false 意味着值不可改变，和你定义一个空的 setter 是有些等价的。实际上，你的空 setter 在被调用时需要扔出一个 TypeError，来和 writable:false 保持一致。</li>
</ul>
</li>
<li>可配置性（Configurable）：只要属性当前是可配置的，我们就可以使用相同的 defineProperty(..) 工具，修改它的描述符定义。<ul>
<li>configurable 设置为 false 是 一个单向操作，不可撤销！</li>
<li>即便属性已经是 configurable:false，writable 总是可以没有错误地从 true 改变为 false，但如果已经是 false 的话不能变回 true。</li>
<li>configurable:false 阻止的另外一个事情是使用 delete 操作符移除既存属性的能力。（delete 仅仅是一个对象属性移除操作 —— 没有更多别的含义。）</li>
</ul>
</li>
<li>可枚举性（Enumerable）：控制着一个属性是否能在特定的对象-属性枚举操作中出现，比如 for..in 循环。设置为 false 将会阻止它出现在这样的枚举中，即使它依然完全是可以访问的。设置为 true 会使它出现。</li>
<li>不可变性（Immutability）：所有 这些方法创建的都是浅不可变性。也就是，它们仅影响对象和它的直属属性的性质。如果对象拥有对其他对象（数组、对象、函数等）的引用，那个对象的 内容 不会受影响，任然保持可变。</li>
</ul>
</li>
<li>对象常量（Object Constant）：通过将 writable:false 与 configurable:false 组合，你可以实质上创建了一个作为对象属性的 常量（不能被改变，重定义或删除。</li>
<li>防止扩展（Prevent Extensions）Object.preventExtensions：防止一个对象被添加新的属性，但另一方面保留其他既存的对象属性。</li>
<li>封印（Seal）Object.seal：在当前的对象上调用 Object.preventExtensions(..)，同时也将它所有的既存属性标记为 configurable:false。</li>
<li>冻结（Freeze）Object.freeze：在当前的对象上调用 Object.seal(..)，同时也将它所有的“数据访问”属性设置为 writable:false。</li>
</ul>
</li>
<li>属性访问和设置：<ul>
<li>[Get]：一个重要结果是，如果它通过任何方法都不能找到被请求的属性的值，那么它会返回 undefined。</li>
<li>[Put]：如果属性存在，[Put] 算法将会大致检查：<ol>
<li>这个属性是访问器描述符吗（见下一节”Getters 与 Setters”）？如果是，而且是 setter，就调用 setter。</li>
<li>这个属性是 writable 为 false 数据描述符吗？如果是，在非 strict mode 下无声地失败，或者在 strict mode 下抛出 TypeError。</li>
<li>否则，像平常一样设置既存属性的值。</li>
</ol>
</li>
<li>Getters 与 Setters：当你将一个属性定义为拥有 getter 或 setter 或两者兼备，那么它的定义就成为了“访问器描述符”（与“数据描述符”相对）。对于访问器描述符，它的 value 和 writable 性质因没有意义而被忽略，取而代之的是 JS 将会考虑属性的 set 和 get 性质（还有 configurable 和 enumerable）。</li>
</ul>
</li>
<li>存在性（Existence）：<ul>
<li>in：会检查属性是否存在于对象 中，或者是否存在于 [Prototype|Prototype] 链对象遍历的更高层中。</li>
<li>hasOwnProperty： 检查 对象 是否拥有属性，但 不会 查询 [Prototype|Prototype] 链。</li>
</ul>
</li>
<li>枚举（Enumeration）：enumerable 属性描述符。<ul>
<li>for..in：若属性enumerable为false，则对象使用 for..in 时不会出现。</li>
<li>propertyIsEnumerable：测试一个给定的属性名是否直 接存 在于对象上，并且是 enumerable:true。</li>
<li>Object.keys(..)：返回一个所有可枚举属性的数组。</li>
<li>Object.getOwnPropertyNames(..)：返回一个 所有 属性的数组，不论能不能枚举。</li>
</ul>
</li>
<li>迭代（Iteration）：<ul>
<li>forEach(..)：将会迭代数组中所有的值，并且忽略回调的返回值。</li>
<li>every(..)：会一直迭代到最后，或者 当回调返回一个 false（或“falsy”）值。</li>
<li>some(..)：会一直迭代到最后，或者 当回调返回一个 true（或“truthy”）值。</li>
<li>for..of：要求被迭代的 东西 提供一个迭代器对象（从一个在语言规范中叫做 @@iterator 的默认内部函数那里得到），每次循环都调用一次这个迭代器对象的 next() 方法，循环迭代的内容就是这些连续的返回值。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch4.md" target="_blank" rel="noopener">第四章: 混合（淆）“类”的对象</a></p>
</blockquote>
<ul>
<li>本章主要讲述 类设计模式/类机制 的基础知识</li>
<li>类只是几种常见设计模式中的一种。</li>
<li>Javascript实际上不拥有类。</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch5.md" target="_blank" rel="noopener">第五章: 原型（Prototype）</a></p>
</blockquote>
<ul>
<li>Object.prototype：每个 普通 的 [Prototype] 链的最顶端，是内建的 Object.prototype。这个对象包含各种在整个 JS 中被使用的共通工具，因为 JavaScript 中所有普通（内建，而非被宿主环境扩展的）的对象都“衍生自”（也就是，使它们的 [Prototype] 顶端为）Object.prototype 对象。</li>
<li>设置与遮蔽属性：考察 myObject.foo = “bar” 赋值的三种场景，当 foo 不直接存在 于 myObject，但 存在 于 myObject 的 [Prototype] 链的更高层时<ol>
<li>如果一个普通的名为 foo 的数据访问属性在 [Prototype] 链的高层某处被找到，而且没有被标记为只读（writable:false），那么一个名为 foo 的新属性就直接添加到 myObject 上，形成一个 遮蔽属性。</li>
<li>如果一个 foo 在 [Prototype] 链的高层某处被找到，但是它被标记为 只读（writable:false） ，那么设置既存属性和在 myObject 上创建遮蔽属性都是 不允许 的。如果代码运行在 strict mode 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，没有发生遮蔽。</li>
<li>如果一个 foo 在 [Prototype] 链的高层某处被找到，而且它是一个 setter（见第三章），那么这个 setter 总是被调用。没有 foo 会被添加到（也就是遮蔽在）myObject 上，这个 foo setter 也不会被重定义。</li>
</ol>
<ul>
<li>如果你想在第二和第三种情况中遮蔽 foo，那你就不能使用 = 赋值，而必须使用 Object.defineProperty(..)（见第三章）将 foo 添加到 myObject。</li>
</ul>
</li>
<li>“类”函数：当通过调用 new Foo() 创建 a 时，在 JavaScript 中，没有这样的拷贝处理发生。你不会创建类的多个实例。你可以创建多个对象，它们的 [Prototype|Prototype] 连接至一个共通对象。但默认地，没有拷贝发生，如此这些对象彼此间最终不会完全分离和切断关系，而是 链接在一起。结果我们得到两个对象，彼此链接。</li>
<li>new解释：在某种意义上劫持了普通函数并将它以另一种方式调用：构建一个对象，外加这个函数要做的其他任何事。</li>
<li>复活“构造器”：foo.constructor 是极其不可靠的，在你的代码中不应依赖的不安全引用。一般来说，这样的引用应当尽量避免。</li>
<li>“（原型）继承”：<ul>
<li>Object.create：Bar.prototype = Object.create( Foo.prototype )。Object.create(..) 凭空 创建 了一个“新”对象，并将这个新对象内部的 [Prototype|Prototype] 链接到你指定的对象上（在这里是 Foo.prototype）。</li>
<li>Object.setPrototypeOf：通过可以设置的 .<strong>proto</strong> 属性。ES6中增加了 Object.setPrototypeOf(..) 辅助工具，它提供了标准且可预见的方法。</li>
</ul>
</li>
<li>考察“类”关系：<ul>
<li>instanceof：用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置。</li>
<li>isPrototypeOf：方法用于测试一个对象是否存在于另一个对象的原型链上。</li>
<li>getPrototypeOf：返回指定对象的原型（内部[Prototype|Prototype]属性的值）。</li>
<li>setPrototypeOf：如果prototype参数不是一个对象或者null(例如，数字，字符串，boolean，或者 undefined)，则什么都不做。否则，该方法将obj的[Prototype|Prototype]修改为新的值。</li>
<li>[<strong>proto</strong>]： Object.prototype 的 [<strong>proto</strong>]  属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部[Prototype|Prototype] (一个对象或 null)。（有争议的，已废弃，不建议使用）。</li>
</ul>
</li>
<li>创建链接：<ul>
<li>Object.create(..)：创建了一个链接到我们指定的对象（foo）上的新对象（bar），这给了我们 [Prototype|Prototype] 机制的所有力量（委托），而且没有 new 函数作为类和构造器调用产生的所有没必要的复杂性，搞乱 .prototype 和 .constructor 引用，或任何其他的多余的东西。</li>
<li>Object.create(null) 创建一个拥有空（也就是 null）[Prototype|Prototype] 链接的对象，如此这个对象不能委托到任何地方。因为这样的对象没有原形链，instancof 操作符（前 面解释过）没有东西可检查，所以它总返回 false。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch6.md" target="_blank" rel="noopener">第六章: 行为委托</a></p>
</blockquote>
<ul>
<li>行为委托：在 JavaScript 中利用的功能的实际机制来说，其重要的实质 全部在于被连接到其他对象的对象。</li>
<li>理论：<ul>
<li>类理论：“抽象”到父类中，并在子类中特化（覆盖）的一般化行为。</li>
<li>委托理论：“OLOO”（objects-linked-to-other-objects），在 JavaScript 中，[Prototype|Prototype] 机制将 对象 链接到其他 对象。</li>
</ul>
</li>
<li>相互委托（不允许）：如果你使 B 链接到 A，然后试着让 A 链接到 B，那么你将得到一个错误。</li>
<li>Classes vs. Objects：<ul>
<li>Classes：OO 设计模式告诉我们要在父类中声明一个基础 render(..)，之后在我们的子类中覆盖它，但不是完全替代它，而是用按钮特定的行为增强这个基础功能。</li>
<li>委托部件对象：使用这种 OLOO 风格的方法，我们不认为 Widget 是一个父类而 Button 是一个子类，Widget 只是一个对象 和某种具体类型的部件也许想要代理到的工具的集合，而且 Button 也只是一个独立的对象（当然，带有委托至 Widget 的链接！）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="你不懂JS：类型与文法"><a href="#你不懂JS：类型与文法" class="headerlink" title="你不懂JS：类型与文法"></a><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/README.md#you-dont-know-js-types--grammar" target="_blank" rel="noopener">你不懂JS：类型与文法</a></h3><blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/ch1.md" target="_blank" rel="noopener">第一章：类型</a></p>
</blockquote>
<ul>
<li>类型的重要意义：<ul>
<li>内建类型：null、undefined、boolean、number、string、object、symbol ， 除了 object 所有这些类型都被称为“基本类型（primitives）。<ul>
<li>正确测试null值：(!a &amp;&amp; typeof a === “object”);</li>
<li>function：它实际上是对象（object）的“子类型”。特别地，一个函数（function）被称为“可调用对象” ，函数对象拥有一个 length 属性，它被设置为函数被声明时的形式参数的数量。</li>
</ul>
</li>
</ul>
</li>
<li>值作为类型：在 JavaScript 中，变量没有类型 – 值才有类型。变量可以在任何时候，持有任何值。<ul>
<li>如果你对一个变量使用 typeof，它不会像表面上看起来那样询问“这个变量的类型是什么？”，因为 JS 变量是没有类型的。取而代之的是，它会询问“在这个变量里的值的类型是什么？”</li>
</ul>
</li>
<li>typeof Undeclared：typeof 的未声明安全防卫给了我们更多选项，这还是很不错的。</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/ch2.md" target="_blank" rel="noopener">第二章：值</a></p>
</blockquote>
<ul>
<li>Array：在一个 array 值上使用 delete 将会从这个 array 上移除一个值槽，但就算你移除了最后一个元素，它也 不会 更新 length 属性，所以多加小心！</li>
<li>String：string 是不可变的。<ul>
<li>“foo”.split(“”).reverse().join(“”); // oof</li>
<li>小心！这种方法对含有复杂（unicode）字符（星型字符、多字节字符等）的 string 不起作用。你需要支持 unicode 的更精巧的工具库来准确地处理这种操作。在这个问题上可以咨询 Mathias Bynens 的作品：Esrever（<a href="https://github.com/mathiasbynens/esrever）。" target="_blank" rel="noopener">https://github.com/mathiasbynens/esrever）。</a></li>
</ul>
</li>
<li>Number:包含“整数”值和小数值。我说“整数”时加了引号，因为 JS 的一个长久以来为人诟病的原因是，和其他语言不同，JS 没有真正的整数。<ul>
<li>安全整数范围：Number.MIN_SAFE_INTEGER - Number.MAX_SAFE_INTEGER。要测试一个值是否是 安全整数：Number.isSafeInteger(..)</li>
<li>测试整数：Number.isInteger(..)</li>
</ul>
</li>
<li>不是值的值：<ul>
<li>Undefined：还没有值。永远不让覆盖 undefined。</li>
<li>null：是一个空值。</li>
</ul>
</li>
<li>特殊的数字：<ul>
<li>不是数字的数字：NaN，它从来不等于它自己。<ul>
<li>isNaN：window.isNaN(..)存在缺陷。在 ES6 中，终于提供了一个替代它的工具：Number.isNaN(..)。</li>
<li>n !== n：借助Nan从来不等于它自己的特殊事实，可以这么简单判断。</li>
</ul>
</li>
<li>无穷：<ul>
<li>var a = 1 / 0;  // Infinity</li>
<li>var b = -1 / 0; // -Infinity</li>
<li>一个有限的正 number 除以 Infinity 呢？简单！0。那一个有限的负 number 处理 Infinity 呢？-0。</li>
</ul>
</li>
<li>零： JavaScript 拥有普通的零 0（也称为正零 +0） 和 一个负零 -0<ul>
<li>将一个负零转换为字符串，它将总会被报告为 “0”。有趣的是，反向操作（从 string 到 number），会得到-0。</li>
<li>-0 === 0; // true。</li>
<li>如果你想在你的代码中区分 -0 和 0。isNegZero =&gt; (Number(n) === 0) &amp;&amp; (1 / Number(n) === -Infinity);</li>
<li>在这些应用程序中，举例来说，如果一个变量的值变成了 0，而它丢失了符号，那么你就丢失了它是从哪个方向移动到 0 的信息。保留零的符号避免了潜在的意外信息丢失。</li>
</ul>
</li>
</ul>
</li>
<li>特殊等价：在 ES6 中，有一个新工具可以用于测试两个值的绝对等价性，而没有任何这些例外。它称为 Object.is(..)<ul>
<li>Object.is(..) 很大程度上是为这些(0, -0, NaN)特殊的等价情况准备的。</li>
</ul>
</li>
<li>值与引用：值的 类型 用来 唯一 控制值是通过值拷贝，还是引用拷贝来赋予。<ul>
<li>简单值（也叫基本标量）：总是 通过值拷贝来赋予/传递：null、undefined、string、number、 boolean、以及 ES6 的 symbol。</li>
<li>复合值：总是 在赋值或传递时创建一个引用的拷贝：Object、Array、Function。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/ch5.md" target="_blank" rel="noopener">第五章：文法</a></p>
</blockquote>
<ul>
<li>语句完成值：把语句敲进你的浏览器开发者控制台，因为当你运行它时，默认地控制台会报告最近一次执行的语句的完成值。<ul>
<li>var语句本身给出的结果是undefined。为什么？因为在语言规范中var语句就是这么定义的。</li>
<li>有一个称为“do表达式”的ES7提案。</li>
</ul>
</li>
<li>表达式副作用：大部分表达式没有副作用，以下除外<ul>
<li><code>++</code>,<code>--</code>：当++像++a这样用于前缀位置时，它的副作用（递增a）发生在值从表达式中返回 之前，而不是a++那样发生在 之后。</li>
<li>delete：如果被请求的操作是合法/可允许的，delete操作符的结果值为true，否则结果为false。但是这个操作符的副作用是它移除了属性（或数组值槽）。</li>
<li>a = b = c = 42：c = 42被求值得出42（带有将42赋值给c的副作用），然后b = 42被求值得出42（带有将42赋值给b的副作用），而最后a = 42被求值（带有将42赋值给a的副作用）。</li>
</ul>
</li>
<li>上下文规则：<ul>
<li>{ .. } 大括号：<ul>
<li>对象字面量：<ul>
<li>实际上完全合法的JSON值{“a”:42}本身将会抛出一个JS错误，因为它被翻译为一个带有非法标签的语句块儿。</li>
<li>JSON-P使JSON成为合法的JS文法！</li>
</ul>
</li>
<li>break/continue：<ul>
<li>一个标签也可以用于一个非循环的块儿，但只有break可以引用这样的非循环标签。</li>
<li>你可以使用带标签的break <strong>_跳出任何被标记的块儿，但你不能continue _</strong>一个非循环标签，也不能用一个不带标签的break跳出一个块儿。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>else if 和可选块儿：JS文法隐藏的性质：它没有else if。但是如果附着在if和else语句后面的代码块儿仅包含一个语句时，if和else语句允许省略这些代码块儿周围的{ }。</li>
<li>操作符优先级：<code>&amp;&amp;</code> &gt; <code>||</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算符优先级</a></li>
<li>自动分号：ASI（Automatic Semicolon Insertion —— 自动分号插入），仅在一个语句和这一行的换行之间除了空格和/或注释没有别的东西时。</li>
<li>try…finally：一般来说，在函数中省略return和return;或者return undefined;是相同的，但是在一个finally块儿内部，return的省略不是用一个return undefined覆盖；它只是让前一个return继续生效。</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/apA.md" target="_blank" rel="noopener">附录A：与环境混合的JavaScript</a></p>
</blockquote>
<ul>
<li>在字符串字面量（不是一个字符串变量）中允许出现的最大字符个数</li>
<li>在一个函数调用的参数值中可以发送的数据的大小（字节数，也称为栈的大小）</li>
<li>在一个函数声明中的参数数量</li>
<li>没有经过优化的调用栈最大深度（比如，使用递归时）：从一个函数到另一个函数的调用链能有多长</li>
<li>JS程序可以持续运行并阻塞浏览器的秒数</li>
<li>变量名的最大长度</li>
<li>…</li>
</ul>
<hr>
<h3 id="你不懂JS-异步与性能"><a href="#你不懂JS-异步与性能" class="headerlink" title="你不懂JS: 异步与性能"></a><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&%20performance/README.md#you-dont-know-js-async--performance" target="_blank" rel="noopener">你不懂JS: 异步与性能</a></h3><blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&%20performance/ch1.md" target="_blank" rel="noopener">第一章: 异步: 现在与稍后</a></p>
</blockquote>
<ul>
<li>块儿（Chunks）中的程序：每当你将一部分代码包进function并且规定它应当为了响应某些事件而执行（定时器，鼠标点击，Ajax应答等等），你就创建了一个 稍后 代码块儿，也因此在你的程序中引入了异步。</li>
<li>异步控制台：<ul>
<li>关于console.*方法如何工作，没有相应的语言规范或一组需求——它们不是JavaScript官方的一部分，而是由 宿主环境 添加到JS上的</li>
<li>到底在什么条件下consoleI/O将被推迟是不确定的，甚至它能不能被观察到都是不确定的。只能当你在调试过程中遇到问题时——对象在console.log(..)语句之后被修改，但你却意外地看到了修改后的内容——意识到I/O的这种可能的异步性。</li>
</ul>
</li>
<li>事件轮询：尽管明确地允许异步JS代码（就像我们刚看到的超时），但是实际上，直到最近（ES6）为止，JavaScript本身从来没有任何内建的异步概念。<ul>
<li>在每次调用JS引擎时，可以 随着时间的推移 执行你的程序的多个代码块儿，这称为“事件轮询（Event Loop）”。</li>
<li>你的程序通常被打断成许多小的代码块儿，它们一个接一个地在事件轮询队列中执行。而且从技术上说，其他与你的程序没有直接关系的事件也可以穿插在队列中。</li>
</ul>
</li>
<li>Jobs：在ES6中，在事件轮询队列之上引入了一层新概念，称为“工作队列（Job queue）”。你最有可能接触它的地方是在Promises。</li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&%20performance/ch2.md" target="_blank" rel="noopener">第二章: 回调</a></p>
</blockquote>
<ul>
<li><strong>本章是故事叙述，主要讲解决回调的一些过渡手段</strong></li>
</ul>
<blockquote>
<p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&%20performance/ch3.md" target="_blank" rel="noopener">第三章: Promises</a></p>
</blockquote>
<ul>
<li>Promise值：<ul>
<li>Promise包装了时间相关的状态——等待当前值的完成或拒绝——从外部看来，Promise本身是时间无关的，如此Promise就可以用可预测的方式组合，而不用关心时间或底层的结果。</li>
<li>一旦Promise被解析，它就永远保持那个状态——它在那个时刻变成了一个 不可变的值。</li>
<li>Promise是一种用来包装与组合 未来值，并且可以很容易复用的机制。</li>
</ul>
</li>
<li>Promise“事件”：<ul>
<li>then(..)注册了”fulfillment（完成）”和/或”rejection（拒绝）”事件</li>
<li>就是Promise（一旦被解析）会永远保持相同的解析结果（完成或拒绝），而且可以按需要后续地被监听任意多次。</li>
</ul>
</li>
<li>Thenable鸭子类型：根据值的形状（存在什么属性）来推测它的“类型”的“类型检查”有一个一般的名称，称为“鸭子类型检查”——“如果它看起来像一只鸭子，并且叫起来像一只鸭子，那么它一定是一只鸭子”<ul>
<li>识别一个Promise（或像Promise一样动作的某些东西）的方法是定义一种称为“thenable”的东西，也就是任何拥有then(..)方法的对象或函数。这种方法假定任何这样的值都是一个符合Promise的thenable。</li>
<li>无论是过去，现在，还是将来，可以拥有then(..)函数，不管是有意的还是偶然的，否则这个值将在Promise系统中被混淆为一个thenable，从而可能产生非常难以追踪的Bug。</li>
</ul>
</li>
<li>信任建立：Promise是一个用可靠语义来增强回调的模式，所以它的行为更合理更可靠。通过将回调的 控制倒转 反置过来，我们将控制交给一个可靠的系统（Promise），它是为了将你的异步处理进行清晰的表达而特意设计的。</li>
<li>链式流程：可以将多个Promise串联在一起来表达一系列的异步步骤。<ul>
<li>在一个Promise上的then(..)调用会自动生成一个新的Promise并返回。</li>
<li>在完成/拒绝处理器内部，如果你返回一个值或抛出一个异常，新返回的Promise（可以被链接的）将会相应地被解析。</li>
<li>如果完成或拒绝处理器返回一个Promise，它会被展开，所以无论它被解析为什么值，这个值都将变成从当前的then(..)返回的被链接的Promise的解析。</li>
</ul>
</li>
<li>错误处理：<ul>
<li>为了回避把一个被遗忘/抛弃的Promise的错误无声地丢失，一些开发者宣称Promise链的“最佳实践”是，总是将你的链条以catch(..)终结。</li>
</ul>
</li>
</ul>
<blockquote>
<p>未完待续…</p>
</blockquote>

                </div>
            </div>
    
            <nav class="post-pagination">
    
    <a class="newer-posts" href="/2019/08/30/服务层的思考/">
        上一篇<br>服务层的思考与实践
    </a>
    
    <span class="page-number"></span>
    
    <a class="older-posts" href="/2018/06/24/Git合作模式/">
        下一篇<br>Git合作模式
    </a>
    
</nav>

    
            


        </div>
    </div>
    <div class="single-column-footer">
    <!-- Proudly published with Hexo<br>
    
    Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>
    
    &copy; 2019 <a href="http://yoursite.com">it&#39;s Me.</a> -->
</div>
</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js" integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js" integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js" integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script>
<script src="/js/journal.js?11687195"></script>



</body>
</html>
