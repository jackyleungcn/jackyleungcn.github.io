<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>it&#39;s Me.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.liangjunqi.com/"/>
  <updated>2019-09-17T03:18:55.587Z</updated>
  <id>http://www.liangjunqi.com/</id>
  
  <author>
    <name>Jacky Leung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初探Flutter踩坑记</title>
    <link href="http://www.liangjunqi.com/2019/09/12/%E5%88%9D%E6%8E%A2Flutter%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>http://www.liangjunqi.com/2019/09/12/初探Flutter踩坑记/</id>
    <published>2019-09-12T02:16:37.000Z</published>
    <updated>2019-09-17T03:18:55.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么对Flutter“动心”了？"><a href="#为什么对Flutter“动心”了？" class="headerlink" title="为什么对Flutter“动心”了？"></a>为什么对Flutter“动心”了？</h1><hr><p>Javascript的跨平台技术，从PhoneGap、Ionic、Electron、ReactNative、Weex，我都了解过，但并没有深入去学习。可能是所在的公司业务并没有这方面的涉猎，互联网时代，技术是服务业务的。</p><p>但实际想想，我觉得更大的原因是，我认为这些方案都是“过渡性”的。直到Flutter，我看了它的实现原理，发现和游戏是如出一辙。对游戏有一定理解的都知道，移植游戏只要接上平台对应的操作接口，硬件的适配，性能跟得上，就可以实现移植到不同平台。基于此，我认为Flutter是一门真正面向跨平台的技术，所以对它“动心”了。</p><h1 id="学习心路历程"><a href="#学习心路历程" class="headerlink" title="学习心路历程"></a>学习心路历程</h1><hr><p>学习一门新技术，我一般会按以下流程：</p><ol><li>收集文档<ul><li>快速定位具体问题，章节，查阅API</li></ul></li><li>敲一遍官方Getting Started<ul><li>熟悉过程，掌握常用API和组件</li></ul></li><li>看技术实现原理<ul><li>了解其原理，增加对Flutter的认识</li></ul></li><li>看实战文章<ul><li>阅读前人踩坑记录，构建技巧</li></ul></li><li>开发应用DEMO<ul><li>“实践是检验真理的唯一标准”，实战开发过才能牢固知识</li></ul></li></ol><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><hr><h3 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h3><ol><li>Pub包管理，需要在<code>pubspec.yaml``dependencies</code>中设置依赖</li><li>库引用，import对应的<code>class</code>文件，解耦封装不同职责的代码</li><li>JSON转化为entity，把JSON贴到 <a href="https://ashamp.github.io/jsonToDartModel/" target="_blank" rel="noopener">Json To Dart Model Code Generator</a>，自动生成</li><li>HTTP，使用<code>dio</code>并封装<code>request</code>、<code>response</code>拦截器(interceptor)</li><li>MD5加密使用<code>crypto</code>包</li><li>使用<code>async/await</code>处理异步</li><li>判断时，变量类型要相同</li><li>加载图片，默认底图使用<code>FadeInImage.assetNetwork</code>的<code>placeholder</code>属性</li><li>事件监听使用<code>GestureDetector</code>组件</li></ol><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><ol><li>appBar头部自定义，使用<code>PreferredSize</code>组件</li><li>画圆角使用<code>ClipRRect</code>组件</li><li>动态列表(List)，使用<code>ListView.builder</code>组件</li><li>底部导航使用<code>BottomNavigationBar</code>组件</li><li>滚动加载下拉刷新使用<code>pull_to_refresh</code>包，内有<code>SmartRefresher</code>组件</li><li>webview使用<code>flutter_webview_plugin</code>包，内有<code>WebviewScaffold</code>组件</li></ol><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><hr><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>中文：<a href="https://flutterchina.club/get-started/codelab/" target="_blank" rel="noopener">https://flutterchina.club/get-started/codelab/</a></p><p>Flutter实战：<a href="https://book.flutterchina.club/" target="_blank" rel="noopener">https://book.flutterchina.club/</a></p><p>英文：<a href="https://flutter.dev/docs" target="_blank" rel="noopener">https://flutter.dev/docs</a>（部分中文不好使，英文文档保持官方最新）</p><h3 id="Dart-1"><a href="#Dart-1" class="headerlink" title="Dart"></a>Dart</h3><p>中文：<a href="http://dart.goodev.org/" target="_blank" rel="noopener">http://dart.goodev.org/</a></p><p>英文：<a href="https://dart.dev/" target="_blank" rel="noopener">https://dart.dev/</a></p><p>Dart学习笔记：<a href="http://www.cndartlang.com/special/dart-notes" target="_blank" rel="noopener">http://www.cndartlang.com/special/dart-notes</a></p><h3 id="实战推荐"><a href="#实战推荐" class="headerlink" title="实战推荐"></a>实战推荐</h3><ol><li>Flutter的原理及美团的实践<ul><li>上：<a href="https://zhuanlan.zhihu.com/p/41731412" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41731412</a></li><li>中：<a href="https://zhuanlan.zhihu.com/p/41731950" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41731950</a></li><li>下：<a href="https://zhuanlan.zhihu.com/p/41732803" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41732803</a></li></ul></li><li>Flutter学习指南：<a href="https://zhuanlan.zhihu.com/flutter" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/flutter</a></li><li>Flutter干货学堂（咸鱼）：<a href="https://zhuanlan.zhihu.com/xytech" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/xytech</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么对Flutter“动心”了？&quot;&gt;&lt;a href=&quot;#为什么对Flutter“动心”了？&quot; class=&quot;headerlink&quot; title=&quot;为什么对Flutter“动心”了？&quot;&gt;&lt;/a&gt;为什么对Flutter“动心”了？&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Javas
      
    
    </summary>
    
      <category term="技术小记" scheme="http://www.liangjunqi.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="Flutter" scheme="http://www.liangjunqi.com/tags/Flutter/"/>
    
      <category term="Dart" scheme="http://www.liangjunqi.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>服务层的思考与实践</title>
    <link href="http://www.liangjunqi.com/2019/08/30/%E6%9C%8D%E5%8A%A1%E5%B1%82%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://www.liangjunqi.com/2019/08/30/服务层的思考/</id>
    <published>2019-08-30T02:04:52.000Z</published>
    <updated>2019-08-30T09:22:19.569Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：平时我们在写Vue和小程序时，习惯的把请求直接写在组件上，这是好的实践吗？是否有更好的处理方法？</p></blockquote><h1 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h1><hr><p>刚开始工作的时候，我第一次接触的就是php。框架是像织梦cms、ecshop。当时前端还没有构建工具，也没有required.js, seajs，更没有前后端分离。前端的工作就是做好静态页面，然后套进php框架的views作为模板。项目组织架构是这样的：</p><pre><code>.├── images/├── js/├── css/├── index.html.</code></pre><p>当时不理解，为什么php框架里，要分model、views、controller三个文件夹？页面是放在views里的，那另外2个文件夹是干嘛的呢？这就是大名鼎鼎的MVC。</p><blockquote><p>模型－视图－控制器（MVC）是Xerox PARC在二十世纪八十年代为编程语言Smalltalk－80发明的一种软件设计模式，已被广泛使用。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。——百度百科</p></blockquote><p>MVC是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p><strong>前人的思想：用分离的方法组织代码</strong></p><h1 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h1><hr><p>日常开发Vue项目的一个例子，目录结构和请求服务封装。</p><pre><code>.├── src│   ├── http│   │     ├── index.js│   ├── views│   │     ├── pageA│   │     │     ├── index.vue│   │     │     ├── index.js│   │     │     ├── index.scss.</code></pre><pre class=" language-javascript"><code class="language-javascript"># index<span class="token punctuation">.</span>js<span class="token keyword">import</span> <span class="token punctuation">{</span>  aGetVipMemberList<span class="token punctuation">,</span>  aGetVipMemberInfo<span class="token punctuation">,</span>  aRemoveVipMember<span class="token punctuation">,</span>  aGetVipMemberGroupList<span class="token punctuation">,</span>  aSetVipMemberEnterGroup<span class="token punctuation">,</span>  aDelVipMemberInGroup<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'src/http'</span><span class="token punctuation">;</span><span class="token function">getPayGroupList</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 请求服务</span>  <span class="token function">aGetVipMemberGroupList</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    app_uid<span class="token punctuation">:</span> uid  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*      * 展示和数据处理耦合在一起     * 作为组件的methods，应该聚焦于展示数据     */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>payGroupList <span class="token operator">=</span> res<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span>        <span class="token operator">...</span>item<span class="token punctuation">,</span>        group_name<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>item<span class="token punctuation">.</span>group_id <span class="token operator">||</span> <span class="token string">''</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>item<span class="token punctuation">.</span>group_name <span class="token operator">||</span> <span class="token string">''</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span>        price<span class="token punctuation">:</span> item<span class="token punctuation">.</span>price <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>pPage<span class="token punctuation">.</span>all <span class="token operator">=</span> res<span class="token punctuation">.</span>total_size<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>pPage<span class="token punctuation">.</span>count <span class="token operator">=</span> res<span class="token punctuation">.</span>total_page<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如上所示，数据获取 -&gt; 数据处理 -&gt; 数据展示，存在以下问题：</p><ol><li>代码耦合在一起，指责不清晰，边界模糊。</li><li>请求服务与页面分离在不同的目录，查找麻烦。</li><li>所有的请求服务都放在<code>src/http/index.js</code>，容易单点错误引发大面积瘫痪。</li></ol><p>由此可见，这里的代码并不分离。随着项目迭代，人员的更替，必定产生巨大的维护成本，招来“技术债”。</p><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><hr><blockquote><p>由于服务借鉴于Angular，这里碎碎念了自己一些经历，想直接看解决方案的可以略过此章节。</p></blockquote><p>说说我认识的AngularJS和Angular</p><p>用过jQuery开发管理后台的人都知道，做一个表单字段的get/set是多繁琐。写iframe与服务端post提交表单是多累赘。当你看见MVVM双向绑定，你会兴奋到从椅子跳起来。</p><p>2014年的时候，当时Vue和React还未火起来。AngularJS的MVVM打开了前端的一个新大陆。我也有幸用它做了一个<code>推送系统</code>，竞品是<code>个推</code>。公司并没有对外商用的计划，所以用于内部产品安卓系统生态的推送。入门概念很多，模块(Module)、依赖注入（DI）、注入器(Injector)、控制器(Controller)、指令(Directive)… 完全颠覆对前端项目架构。当趟过坑，感受就两字，真香。</p><p>直到2015年，AngularJS被“放弃”，Google出了Angular2。嗯，完全不同，而且当时版本连跑“Hello World”成功都困难。同时React悄悄在社区中壮大，Vue也快步前进。鉴于“前端无大项目”，学习成本低且轻量级界面库更容易让人接受，我也慢慢的离开Angular的怀抱。但那种项目组织，却忘不了。</p><p>直到17、18年，我在用Vue开发公司的管理后台时，遇到很多麻烦。</p><ol><li>目录组织太自由。萝卜青菜各有所爱，我***。</li><li>代码写法太自由，用ESlint，是要基于你用什么插件，甚至是插件的vue/essential还是recommended?要配合其他如prettier？</li><li>Object嵌套与模板绑定、组件props传递的抛error。</li><li>父子组件交互各异，this.$refs.child.childFunc。</li><li>Vuex，你是用{ mapGetters, … } from ‘vuex’全家桶呢，还是this.$store.state.xxx呢？随缘，你喜欢。</li></ol><p>不一一列举太多，诸如以上问题，是不是不能解决？不是，但怎么解决？靠团队规范，项目规范。但前提是，需求要做，没时间去梳理，而且以当时的知识积累并不完善，要做一个好的项目规范，也只是现阶段合适罢了。</p><p>我开始想，之前做NG的时候，好像我都不用考虑这些。我就写实现，那项目组织也没那么多问题。为什么？因为实现NG的Google团队维护了条条框框来限定你的代码，以至于你必须在特定的地方写特定的内容，做到<strong>用分离的方法组织代码</strong>。</p><p>基于此想法，在工作间隙，我开始重拾Angular。同时也丰富了诸如代码组织、项目组织、Typescript、代码指责的思想和概念。所以在19年做运维管理系统，我就下定决心一定要选型Angular。</p><h1 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h1><hr><blockquote><p>组件不应该直接获取或保存数据，它们不应该了解是否在展示假数据。 它们应该聚焦于展示数据，而把数据访问的职责委托给某个服务。——Angular tutorial</p></blockquote><pre><code>.├── src│   ├── http│   │     ├── config.js                 // 服务配置│   │     ├── index.js                  // 提供挂载函数│   ├── views│   │     ├── pageA│   │     │     ├── index.vue│   │     │     ├── index.js            // 服务实例化│   │     │     ├── index.scss│   │     │     ├── index.service.js    // 组件服务层│   ├── main.js                         // 注册挂载服务.</code></pre><pre class=" language-javascript"><code class="language-javascript"># src<span class="token operator">/</span>http<span class="token operator">/</span>config<span class="token punctuation">.</span>js <span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token punctuation">;</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> axios</code></pre><pre class=" language-javascript"><code class="language-javascript"># src<span class="token operator">/</span>http<span class="token operator">/</span>index<span class="token punctuation">.</span>js<span class="token keyword">import</span> http <span class="token keyword">from</span> <span class="token string">'./config'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token function">install</span><span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">{</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$http <span class="token operator">=</span> http<span class="token punctuation">;</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$post <span class="token operator">=</span> <span class="token punctuation">(</span>url<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>          <span class="token keyword">return</span> http<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$<span class="token keyword">get</span> <span class="token operator">=</span> <span class="token punctuation">(</span>url<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>          <span class="token keyword">return</span> http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"># src<span class="token operator">/</span>main<span class="token punctuation">.</span>js<span class="token keyword">import</span> http <span class="token keyword">from</span> <span class="token string">'./http/index'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>http<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-javascript"><code class="language-javascript"># src<span class="token operator">/</span>views<span class="token operator">/</span>pageA<span class="token operator">/</span>index<span class="token punctuation">.</span>service<span class="token punctuation">.</span>js<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">service</span> <span class="token keyword">extends</span> <span class="token class-name">Vue</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">async</span> <span class="token function">api1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$post</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 按视图需要，预先处理好res数据     * ...     */</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> service</code></pre><pre class=" language-javascript"><code class="language-javascript"># src<span class="token operator">/</span>views<span class="token operator">/</span>pageA<span class="token operator">/</span>index<span class="token punctuation">.</span>js<span class="token keyword">import</span> service <span class="token keyword">from</span> <span class="token string">'./service'</span><span class="token punctuation">;</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>_$service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">service</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token function">_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_$service<span class="token punctuation">.</span><span class="token function">api1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h5><ol><li>服务创建<ul><li><code>src/http/config.js</code>，用于服务配置，如res、req拦截过滤。</li><li><code>src/http/index.js</code>，用于提供挂载函数，如实现Vue的<code>install</code>函数并暴露。</li><li><code>src/main.js</code>，挂载服务Vue.use(http)。</li></ul></li><li>服务层<ul><li><code>src/views/pageA/index.service.js</code>，服务逻辑实现。</li></ul></li><li>组件<ul><li><code>src/views/pageA/index.js</code>，this._$service = new service()，组件调用。</li></ul></li></ol><h5 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h5><ol><li>代码耦合在一起，指责不清晰，边界模糊。<ul><li>View负责展示逻辑。</li><li>Service负责数据获取，处理。</li></ul></li><li>请求服务与页面分离在不同的目录，查找麻烦。<ul><li>index.js和index.service.js在同一个目录下，快速定位。</li></ul></li><li>所有的请求服务都放在<code>src/http/index.js</code>，容易单点错误引发大面积瘫痪。<ul><li>http分散到不同目录，错误只会影响到当前组件。</li></ul></li></ol><h1 id="层的思考"><a href="#层的思考" class="headerlink" title="层的思考"></a>层的思考</h1><hr><p>部分开发者可能认为，服务层的引入多此一举。</p><p>确实，引入服务层会让编码隔离，甚至繁琐。可是，在大型应用开发中，层级的划分是必须的，其对应的指责要清晰确定。这是多人合作开发不同系统模块，至下而上，形成一个健壮的应用的前提。</p><p>本文通篇围绕着一句话：<strong>用分离的方法组织代码</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：平时我们在写Vue和小程序时，习惯的把请求直接写在组件上，这是好的实践吗？是否有更好的处理方法？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;过去&quot;&gt;&lt;a href=&quot;#过去&quot; class=&quot;headerlink&quot; title=&quot;过去
      
    
    </summary>
    
      <category term="技术小记" scheme="http://www.liangjunqi.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://www.liangjunqi.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>你不懂JS（You-Dont-Know-JS）阅读总结</title>
    <link href="http://www.liangjunqi.com/2019/05/08/%E4%BD%A0%E4%B8%8D%E6%87%82JS%EF%BC%88You-Dont-Know-JS%EF%BC%89%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://www.liangjunqi.com/2019/05/08/你不懂JS（You-Dont-Know-JS）阅读总结/</id>
    <published>2019-05-08T08:04:23.000Z</published>
    <updated>2019-08-29T06:18:19.299Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文作为阅读【你不懂JS（You-Dont-Know-JS）】系列丛书的笔记总结，持续更新内容。旨在每章的关键概念，方便日后翻查。</p></blockquote><h3 id="你不懂JS：作用域与闭包"><a href="#你不懂JS：作用域与闭包" class="headerlink" title="你不懂JS：作用域与闭包"></a><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/README.md#you-dont-know-js-scope--closures" target="_blank" rel="noopener">你不懂JS：作用域与闭包</a></h3><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch1.md" target="_blank" rel="noopener">第一章：什么是作用域？</a></p></blockquote><ul><li>编译器理论：尽管 JavaScript 一般被划分到“动态”或者“解释型”语言的范畴，但是其实它是一个编译型语言。<ul><li>分词：将一连串字符打断成（对于语言来说）有意义的片段，称为 token（记号）。</li><li>解析：将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为“抽象语法树”（AST —— Abstract Syntax Tree）。</li><li>代码生成：这个处理将抽象语法树转换为可执行的代码。</li></ul></li><li>引擎：<ul><li>LHS(赋值)：引擎 在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个 全局作用域 将会在 全局作用域中 创建一个同名的新变量，并把它交还给 引擎。</li><li>RHS(取值)：如果 RHS 查询在嵌套的 作用域 的任何地方都找不到一个值，这会导致 引擎 抛出一个 ReferenceError。</li><li>嵌套作用域：遍历嵌套 作用域 的简单规则：引擎 从当前执行的 作用域 开始，在那里查找变量，如果没有找到，就向上走一级继续查找，如此类推。如果到了最外层的全局作用域，那么查找就会停止，无论它是否找到了变量。</li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch2.md" target="_blank" rel="noopener">第二章：词法作用域</a></p></blockquote><ul><li>词法作用域：词法作用域是在词法分析时被定义的作用域。换句话说，词法作用域是基于，你，在写程序时，变量和作用域的块儿在何处被编写决定的，因此它在词法分析器处理你的代码时（基本上）是固定不变的。</li><li>词法分析时：词法作用域是基于，你，在写程序时，变量和作用域的块儿在何处被编写决定的，因此它在词法分析器处理你的代码时（基本上）是固定不变的。</li><li>查找：一旦找到第一个匹配，作用域查询就停止了。</li><li>欺骗词法作用域：eval(..) 和 with 都受Strict模式的影响（制约）。with 干脆就不允许使用，而虽然 eval(..) 还保有其核心功能，但各种间接形式的或不安全的 eval(..) 是不允许的。<ul><li>eval: 动态生成的函数的代码。 with: 将这个对象视为好像它是一个完全隔离的词法作用域。<ul><li>性能：JavaScript 引擎 在编译阶段期行许多性能优化工作。其中的一些优化原理都归结为实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明都在什么位置，这样在执行期间就可以少花些力气来解析标识符。无论 引擎 将在努力限制这些悲观臆测的副作用上表现得多么聪明，都没有任何办法可以绕过这个事实：没有优化，代码就运行的更慢。</li></ul></li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch3.md" target="_blank" rel="noopener">第三章：函数与块儿作用域</a></p></blockquote><ul><li>函数中的作用域：<ul><li>隐藏于普通作用域。</li><li>避免冲突。</li><li>模块管理。</li></ul></li><li>函数作为作用域：<ul><li>匿名与命名：总是命名你的函数表达式。</li><li>立即调用函数表达式。</li></ul></li><li>块儿作为作用域：<ul><li>try/catch：一个鲜为人知的事实是，JavaScript 在 ES3 中明确指出在 try/catch 的 catch 子句中声明的变量，是属于 catch 块儿的块儿作用域的。</li><li>let：我们可以在一个语句是合法文法的任何地方，通过简单地引入一个 { .. } 来为 let 创建一个任意的可以绑定的块儿。</li><li>垃圾回收：块儿作用域的另一个有用之处是关于闭包和释放内存的垃圾回收。</li><li>const：任何稍后改变它的企图都将导致错误。</li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch4.md" target="_blank" rel="noopener">第四章：提升</a></p></blockquote><ul><li>编译器：<ul><li>引擎：实际上将会在它解释执行你的 JavaScript 代码之前编译它。编译过程的一部分就是找到所有的声明，并将它们关联在合适的作用域上。</li><li>提升：是以作用域为单位的 只有声明本身被提升了，而任何赋值或者其他的执行逻辑都被留在 原处。</li></ul></li><li>函数优先：<ul><li>函数声明 &gt; 变量声明：都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，函数会首先被提升，然后才是变量。</li><li>避免在块儿中声明函数可能是最好的做法。</li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/ch5.md" target="_blank" rel="noopener">第五章：作用域闭包</a></p></blockquote><ul><li>闭包：<ul><li>在 JavaScript 中闭包无所不在，你只是必须认出它并接纳它。</li><li>闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。</li></ul></li><li>模块：<ul><li>通过在模块实例内部持有一个指向公有API对象的内部引用，你可以 从内部 修改这个模块，包括添加和删除方法，属性，和 改变它们的值。</li><li>现代的模块：调用一个函数定义包装器，并将它的返回值作为这个模块的API保存下来。</li><li>未来的模块：ES6 模块 没有 “内联”格式，它们必须被定义在一个分离的文件中（每个模块一个）。浏览器/引擎拥有一个默认的“模块加载器”（它是可以被覆盖的，但是这超出我们在此讨论的范围），它在模块被导入时同步地加载模块文件。</li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/README.md#you-dont-know-js-scope--closures" target="_blank" rel="noopener">附录</a></p></blockquote><ul><li><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/apA.md" target="_blank" rel="noopener">附录A：动态作用域</a>：<ul><li>要清楚，JavaScript 实际上没有动态作用域。它拥有词法作用域。就这么简单。但是 this 机制有些像动态作用域。</li><li>关键的差异：词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是 函数在何处被声明，但是动态作用域关心的是函数 从何处 被调用。</li></ul></li><li><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/apB.md" target="_blank" rel="noopener">附录B：填补块儿作用域</a>：<ul><li>try/catch：catch 子句拥有块儿作用域。</li><li>隐含的与明确的块儿：你可以使用更好的和更明确的 let 语句形式，即便它（还）不是任何 ES 官方版本的一部分。</li><li>性能：你是否想要使用块儿作用域。如果是，这些工具给你提供了这些选择。如果不，那就在你的代码中继续使用 var。</li></ul></li><li><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/apC.md" target="_blank" rel="noopener">附录C：词法this</a>：<ul><li>箭头函数：采用它们的直接外围词法作用域的 this 的值，无论它是什么。</li><li>正确地使用并接受this机制：不管你是偏好箭头函数的新的词法 this 行为，还是偏好经得起考验的 bind()，重要的是要注意箭头函数 不 仅仅是关于可以少打一些“function”。</li></ul></li><li><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&%20closures/apD.md" target="_blank" rel="noopener">附录D: 鸣谢</a>：<ul><li>但愿这部丛书被我们所有人“拥有”，并为增进对 JavaScript 语言的意识和理解做出贡献，成为当下和未来所有社区贡献者的助益。</li></ul></li></ul><hr><h3 id="你不懂JS-this-与对象原型"><a href="#你不懂JS-this-与对象原型" class="headerlink" title="你不懂JS: this 与对象原型"></a><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes" target="_blank" rel="noopener">你不懂JS: this 与对象原型</a></h3><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch1.md" target="_blank" rel="noopener">第一章: this 是什么？</a></p></blockquote><ul><li>为什么要用 this？：<ul><li>将执行环境作为一个明确参数传递，通常比传递 this 执行环境要乱。当我们探索对象和原型时，你将会看到一组可以自动引用恰当执行环境对象的函数是多么有用。</li></ul></li><li>它的作用域：<ul><li>this 不会以任何方式指向函数的 词法作用域。</li><li>this 不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。this 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。</li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch2.md" target="_blank" rel="noopener">第二章: this 豁然开朗！</a></p></blockquote><ul><li>调用点（Call-site）和 调用栈（call-stack）：<ul><li>调用点：函数在代码中被调用的位置（不是被声明的位置）。</li><li>调用栈：使我们到达当前执行位置而被调用的所有方法的堆栈。</li></ul></li><li>绑定规则：this 绑定规则都是完全基于调用点的<ul><li>默认绑定（Default Binding）：独立函数调用。可以认为这种 this 规则是在没有其他规则适用时的默认规则。（默认绑定来说 全局对象（window/global） 是唯一合法的。strict mode下 this 将被设置为 undefined）。</li><li>隐含绑定（Implicit Binding）：调用点是否有一个环境对象（context object）。对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用。<ul><li>隐含丢失（Implicitly Lost）：在赋值给一个变量或传参，隐含绑定丢失了它的绑定，这通常意味着它会退回到 默认绑定， 根据 strict mode 的状态，其结果不是全局对象就是 undefined。</li></ul></li><li>明确绑定（Explicit Binding）：函数拥有 call(..) 和 apply(..) 方法。它们接收的第一个参数都是一个用于 this 的对象，之后使用这个指定的 this 来调用函数。因为你已经直接指明你想让 this 是什么。<ul><li>硬绑定（Hard Binding）：bind(..) 返回一个硬编码的新函数，它使用你指定的 this 环境来调用原本的函数。</li><li>API 调用的“环境”：许多库中的函数，和许多在 JavaScript 语言以及宿主环境中的内建函数，都提供一个可选参数，通常称为“环境（context）”，这种设计作为一种替代方案来确保你的回调函数使用特定的 this 而不必非得使用 bind(..)。从内部来说，几乎可以确定这种类型的函数是通过 call(..) 或 apply(..) 来使用 明确绑定 以节省你的麻烦。</li></ul></li><li>new 绑定（new Binding）：构建了一个新的对象并把这个新对象作为 foo(..) 调用的 this。</li></ul></li><li>判定 this：<ol><li>函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。</li><li>函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。</li><li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。</li><li>否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。</li></ol></li><li>this特例：<ul><li>被忽略的this：如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</li><li>更安全的this：为了 this 而传递一个特殊创建好的对象，这个对象保证不会对你的程序产生副作用。创建 完全为空的对象 的最简单方法就是 Object.create(null)，Object.create(null) 和 {} 很相似，但是没有指向 Object.prototype 的委托，所以它比 {} “空得更彻底”。</li><li>间接引用（indirect reference）：(p.foo = o.foo)()，赋值表达式 p.foo = o.foo 的 结果值 是一个刚好指向底层函数对象的引用。如此，起作用的调用点就是 foo()，而非你期待的 p.foo() 或 o.foo()。根据上面的规则，默认绑定 适用。</li><li>软化绑定（Softening Binding）：为 默认绑定 提供不同的默认值（不是 global 或 undefined），同时保持函数可以通过 隐含绑定 或 明确绑定 技术来手动绑定 this。</li></ul></li><li>词法 this：<ul><li>箭头函数（arrow-function）：不是通过 function 关键字声明的，而是通过所谓的“大箭头”操作符：=&gt;。与使用四种标准的 this 规则不同的是，箭头函数从封闭它的（函数或全局）作用域采用 this 绑定。</li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch3.md" target="_blank" rel="noopener">第三章：对象</a></p></blockquote><ul><li>类型：<ul><li>简单基本类型：string、number、boolean、null、和 undefined 自身 不是 object。null 有时会被当成一个对象类型，但是这种误解源自于一个语言中的 Bug，它使得 typeof null 错误地（而且令人困惑地）返回字符串 “object”。实际上，null 是它自己的基本类型。</li><li>复杂基本类型：<ul><li>function：是对象的一种子类型（技术上讲，叫做“可调用对象”）。函数在 JS 中被称为“头等（first class）”类型，是因为它们基本上就是普通的对象（附带有可调用的行为语义），而且它们可以像其他普通的对象那样被处理。</li><li>array：数组也是一种形式的对象，带有特别的行为。数组在内容的组织上要稍稍比一般的对象更加结构化。</li></ul></li></ul></li><li>内建对象：String、Number、Boolean、Object、Function、Array、Date、RegExp、Error。<ul><li>有字面量和对象：String、Number、Boolean。（如：必要的时候语言会自动地将 “string” 基本类型强制转换为 String 对象类型，这意味着你几乎从不需要明确地创建对象。）</li><li>都是对象：无论使用字面还是构造形式，Object、Array、Function、RegExp。</li><li>只能构造形式：Date。</li><li>Error：Error 对象很少在代码中明示地被创建，它们通常在抛出异常时自动地被创建。</li></ul></li><li>内容：对象的内容由存储在特定命名的 位置 上的（任意类型的）值组成，我们称这些值为属性。<ul><li>属性名： 总是 字符串。如果你使用 string 以外的（基本）类型值，它会首先被转换为字符串。这甚至包括在数组中常用于索引的数字，所以要小心不要将对象和数组使用的数字搞混了。</li></ul></li><li>属性（Property） vs. 方法（Method）：<ul><li>从技术上讲，函数绝不会“属于”对象。</li><li>就算你声明一个函数表达式作为字面对象的一部分，那个函数都不会魔法般地 属于 这个对象 —— 仍然仅仅是同一个函数对象的多个引用罢了。</li></ul></li><li>数组：<ul><li>注意，添加命名属性（不论是使用 . 还是 [ ] 操作符语法）不会改变数组的 length 所报告的值。</li><li>如果你试图在一个数组上添加属性，但是属性名 看起来 像一个数字，那么最终它会成为一个数字索引。</li></ul></li><li>复制对象：<ul><li>一个解决方案是，JSON 安全的对象可以简单地这样 复制：：var newObj = JSON.parse( JSON.stringify( someObj ) )。</li><li>浅拷贝：相当易懂，而且没有那么多问题，所以 ES6 为此任务已经定义了 Object.assign(..)。在 Object.assign(..) 中发生的复制是单纯的 = 式赋值，所以任何在源对象属性的特殊性质（比如 writable）在目标对象上 都不会保留 。</li></ul></li><li>属性描述符：<ul><li>Object.getOwnPropertyDescriptor：返回 { value、writable、enumerable、configurable }。</li><li>Object.defineProperty：添加新属性，或使用期望的性质来修改既存的属性（如果它是 configurable 的！）。<ul><li>可写性（Writable）：writable 控制着你改变属性值的能力。（如果writable是false，strict mode会得到一个错误TypeError）<ul><li>简单地说，你可以观察到 writable:false 意味着值不可改变，和你定义一个空的 setter 是有些等价的。实际上，你的空 setter 在被调用时需要扔出一个 TypeError，来和 writable:false 保持一致。</li></ul></li><li>可配置性（Configurable）：只要属性当前是可配置的，我们就可以使用相同的 defineProperty(..) 工具，修改它的描述符定义。<ul><li>configurable 设置为 false 是 一个单向操作，不可撤销！</li><li>即便属性已经是 configurable:false，writable 总是可以没有错误地从 true 改变为 false，但如果已经是 false 的话不能变回 true。</li><li>configurable:false 阻止的另外一个事情是使用 delete 操作符移除既存属性的能力。（delete 仅仅是一个对象属性移除操作 —— 没有更多别的含义。）</li></ul></li><li>可枚举性（Enumerable）：控制着一个属性是否能在特定的对象-属性枚举操作中出现，比如 for..in 循环。设置为 false 将会阻止它出现在这样的枚举中，即使它依然完全是可以访问的。设置为 true 会使它出现。</li><li>不可变性（Immutability）：所有 这些方法创建的都是浅不可变性。也就是，它们仅影响对象和它的直属属性的性质。如果对象拥有对其他对象（数组、对象、函数等）的引用，那个对象的 内容 不会受影响，任然保持可变。</li></ul></li><li>对象常量（Object Constant）：通过将 writable:false 与 configurable:false 组合，你可以实质上创建了一个作为对象属性的 常量（不能被改变，重定义或删除。</li><li>防止扩展（Prevent Extensions）Object.preventExtensions：防止一个对象被添加新的属性，但另一方面保留其他既存的对象属性。</li><li>封印（Seal）Object.seal：在当前的对象上调用 Object.preventExtensions(..)，同时也将它所有的既存属性标记为 configurable:false。</li><li>冻结（Freeze）Object.freeze：在当前的对象上调用 Object.seal(..)，同时也将它所有的“数据访问”属性设置为 writable:false。</li></ul></li><li>属性访问和设置：<ul><li>[Get]：一个重要结果是，如果它通过任何方法都不能找到被请求的属性的值，那么它会返回 undefined。</li><li>[Put]：如果属性存在，[Put] 算法将会大致检查：<ol><li>这个属性是访问器描述符吗（见下一节”Getters 与 Setters”）？如果是，而且是 setter，就调用 setter。</li><li>这个属性是 writable 为 false 数据描述符吗？如果是，在非 strict mode 下无声地失败，或者在 strict mode 下抛出 TypeError。</li><li>否则，像平常一样设置既存属性的值。</li></ol></li><li>Getters 与 Setters：当你将一个属性定义为拥有 getter 或 setter 或两者兼备，那么它的定义就成为了“访问器描述符”（与“数据描述符”相对）。对于访问器描述符，它的 value 和 writable 性质因没有意义而被忽略，取而代之的是 JS 将会考虑属性的 set 和 get 性质（还有 configurable 和 enumerable）。</li></ul></li><li>存在性（Existence）：<ul><li>in：会检查属性是否存在于对象 中，或者是否存在于 [Prototype|Prototype] 链对象遍历的更高层中。</li><li>hasOwnProperty： 检查 对象 是否拥有属性，但 不会 查询 [Prototype|Prototype] 链。</li></ul></li><li>枚举（Enumeration）：enumerable 属性描述符。<ul><li>for..in：若属性enumerable为false，则对象使用 for..in 时不会出现。</li><li>propertyIsEnumerable：测试一个给定的属性名是否直 接存 在于对象上，并且是 enumerable:true。</li><li>Object.keys(..)：返回一个所有可枚举属性的数组。</li><li>Object.getOwnPropertyNames(..)：返回一个 所有 属性的数组，不论能不能枚举。</li></ul></li><li>迭代（Iteration）：<ul><li>forEach(..)：将会迭代数组中所有的值，并且忽略回调的返回值。</li><li>every(..)：会一直迭代到最后，或者 当回调返回一个 false（或“falsy”）值。</li><li>some(..)：会一直迭代到最后，或者 当回调返回一个 true（或“truthy”）值。</li><li>for..of：要求被迭代的 东西 提供一个迭代器对象（从一个在语言规范中叫做 @@iterator 的默认内部函数那里得到），每次循环都调用一次这个迭代器对象的 next() 方法，循环迭代的内容就是这些连续的返回值。</li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch4.md" target="_blank" rel="noopener">第四章: 混合（淆）“类”的对象</a></p></blockquote><ul><li>本章主要讲述 类设计模式/类机制 的基础知识</li><li>类只是几种常见设计模式中的一种。</li><li>Javascript实际上不拥有类。</li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch5.md" target="_blank" rel="noopener">第五章: 原型（Prototype）</a></p></blockquote><ul><li>Object.prototype：每个 普通 的 [Prototype] 链的最顶端，是内建的 Object.prototype。这个对象包含各种在整个 JS 中被使用的共通工具，因为 JavaScript 中所有普通（内建，而非被宿主环境扩展的）的对象都“衍生自”（也就是，使它们的 [Prototype] 顶端为）Object.prototype 对象。</li><li>设置与遮蔽属性：考察 myObject.foo = “bar” 赋值的三种场景，当 foo 不直接存在 于 myObject，但 存在 于 myObject 的 [Prototype] 链的更高层时<ol><li>如果一个普通的名为 foo 的数据访问属性在 [Prototype] 链的高层某处被找到，而且没有被标记为只读（writable:false），那么一个名为 foo 的新属性就直接添加到 myObject 上，形成一个 遮蔽属性。</li><li>如果一个 foo 在 [Prototype] 链的高层某处被找到，但是它被标记为 只读（writable:false） ，那么设置既存属性和在 myObject 上创建遮蔽属性都是 不允许 的。如果代码运行在 strict mode 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，没有发生遮蔽。</li><li>如果一个 foo 在 [Prototype] 链的高层某处被找到，而且它是一个 setter（见第三章），那么这个 setter 总是被调用。没有 foo 会被添加到（也就是遮蔽在）myObject 上，这个 foo setter 也不会被重定义。</li></ol><ul><li>如果你想在第二和第三种情况中遮蔽 foo，那你就不能使用 = 赋值，而必须使用 Object.defineProperty(..)（见第三章）将 foo 添加到 myObject。</li></ul></li><li>“类”函数：当通过调用 new Foo() 创建 a 时，在 JavaScript 中，没有这样的拷贝处理发生。你不会创建类的多个实例。你可以创建多个对象，它们的 [Prototype|Prototype] 连接至一个共通对象。但默认地，没有拷贝发生，如此这些对象彼此间最终不会完全分离和切断关系，而是 链接在一起。结果我们得到两个对象，彼此链接。</li><li>new解释：在某种意义上劫持了普通函数并将它以另一种方式调用：构建一个对象，外加这个函数要做的其他任何事。</li><li>复活“构造器”：foo.constructor 是极其不可靠的，在你的代码中不应依赖的不安全引用。一般来说，这样的引用应当尽量避免。</li><li>“（原型）继承”：<ul><li>Object.create：Bar.prototype = Object.create( Foo.prototype )。Object.create(..) 凭空 创建 了一个“新”对象，并将这个新对象内部的 [Prototype|Prototype] 链接到你指定的对象上（在这里是 Foo.prototype）。</li><li>Object.setPrototypeOf：通过可以设置的 .<strong>proto</strong> 属性。ES6中增加了 Object.setPrototypeOf(..) 辅助工具，它提供了标准且可预见的方法。</li></ul></li><li>考察“类”关系：<ul><li>instanceof：用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置。</li><li>isPrototypeOf：方法用于测试一个对象是否存在于另一个对象的原型链上。</li><li>getPrototypeOf：返回指定对象的原型（内部[Prototype|Prototype]属性的值）。</li><li>setPrototypeOf：如果prototype参数不是一个对象或者null(例如，数字，字符串，boolean，或者 undefined)，则什么都不做。否则，该方法将obj的[Prototype|Prototype]修改为新的值。</li><li>[<strong>proto</strong>]： Object.prototype 的 [<strong>proto</strong>]  属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部[Prototype|Prototype] (一个对象或 null)。（有争议的，已废弃，不建议使用）。</li></ul></li><li>创建链接：<ul><li>Object.create(..)：创建了一个链接到我们指定的对象（foo）上的新对象（bar），这给了我们 [Prototype|Prototype] 机制的所有力量（委托），而且没有 new 函数作为类和构造器调用产生的所有没必要的复杂性，搞乱 .prototype 和 .constructor 引用，或任何其他的多余的东西。</li><li>Object.create(null) 创建一个拥有空（也就是 null）[Prototype|Prototype] 链接的对象，如此这个对象不能委托到任何地方。因为这样的对象没有原形链，instancof 操作符（前 面解释过）没有东西可检查，所以它总返回 false。</li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch6.md" target="_blank" rel="noopener">第六章: 行为委托</a></p></blockquote><ul><li>行为委托：在 JavaScript 中利用的功能的实际机制来说，其重要的实质 全部在于被连接到其他对象的对象。</li><li>理论：<ul><li>类理论：“抽象”到父类中，并在子类中特化（覆盖）的一般化行为。</li><li>委托理论：“OLOO”（objects-linked-to-other-objects），在 JavaScript 中，[Prototype|Prototype] 机制将 对象 链接到其他 对象。</li></ul></li><li>相互委托（不允许）：如果你使 B 链接到 A，然后试着让 A 链接到 B，那么你将得到一个错误。</li><li>Classes vs. Objects：<ul><li>Classes：OO 设计模式告诉我们要在父类中声明一个基础 render(..)，之后在我们的子类中覆盖它，但不是完全替代它，而是用按钮特定的行为增强这个基础功能。</li><li>委托部件对象：使用这种 OLOO 风格的方法，我们不认为 Widget 是一个父类而 Button 是一个子类，Widget 只是一个对象 和某种具体类型的部件也许想要代理到的工具的集合，而且 Button 也只是一个独立的对象（当然，带有委托至 Widget 的链接！）。</li></ul></li></ul><hr><h3 id="你不懂JS：类型与文法"><a href="#你不懂JS：类型与文法" class="headerlink" title="你不懂JS：类型与文法"></a><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/README.md#you-dont-know-js-types--grammar" target="_blank" rel="noopener">你不懂JS：类型与文法</a></h3><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/ch1.md" target="_blank" rel="noopener">第一章：类型</a></p></blockquote><ul><li>类型的重要意义：<ul><li>内建类型：null、undefined、boolean、number、string、object、symbol ， 除了 object 所有这些类型都被称为“基本类型（primitives）。<ul><li>正确测试null值：(!a &amp;&amp; typeof a === “object”);</li><li>function：它实际上是对象（object）的“子类型”。特别地，一个函数（function）被称为“可调用对象” ，函数对象拥有一个 length 属性，它被设置为函数被声明时的形式参数的数量。</li></ul></li></ul></li><li>值作为类型：在 JavaScript 中，变量没有类型 – 值才有类型。变量可以在任何时候，持有任何值。<ul><li>如果你对一个变量使用 typeof，它不会像表面上看起来那样询问“这个变量的类型是什么？”，因为 JS 变量是没有类型的。取而代之的是，它会询问“在这个变量里的值的类型是什么？”</li></ul></li><li>typeof Undeclared：typeof 的未声明安全防卫给了我们更多选项，这还是很不错的。</li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/ch2.md" target="_blank" rel="noopener">第二章：值</a></p></blockquote><ul><li>Array：在一个 array 值上使用 delete 将会从这个 array 上移除一个值槽，但就算你移除了最后一个元素，它也 不会 更新 length 属性，所以多加小心！</li><li>String：string 是不可变的。<ul><li>“foo”.split(“”).reverse().join(“”); // oof</li><li>小心！这种方法对含有复杂（unicode）字符（星型字符、多字节字符等）的 string 不起作用。你需要支持 unicode 的更精巧的工具库来准确地处理这种操作。在这个问题上可以咨询 Mathias Bynens 的作品：Esrever（<a href="https://github.com/mathiasbynens/esrever）。" target="_blank" rel="noopener">https://github.com/mathiasbynens/esrever）。</a></li></ul></li><li>Number:包含“整数”值和小数值。我说“整数”时加了引号，因为 JS 的一个长久以来为人诟病的原因是，和其他语言不同，JS 没有真正的整数。<ul><li>安全整数范围：Number.MIN_SAFE_INTEGER - Number.MAX_SAFE_INTEGER。要测试一个值是否是 安全整数：Number.isSafeInteger(..)</li><li>测试整数：Number.isInteger(..)</li></ul></li><li>不是值的值：<ul><li>Undefined：还没有值。永远不让覆盖 undefined。</li><li>null：是一个空值。</li></ul></li><li>特殊的数字：<ul><li>不是数字的数字：NaN，它从来不等于它自己。<ul><li>isNaN：window.isNaN(..)存在缺陷。在 ES6 中，终于提供了一个替代它的工具：Number.isNaN(..)。</li><li>n !== n：借助Nan从来不等于它自己的特殊事实，可以这么简单判断。</li></ul></li><li>无穷：<ul><li>var a = 1 / 0;  // Infinity</li><li>var b = -1 / 0; // -Infinity</li><li>一个有限的正 number 除以 Infinity 呢？简单！0。那一个有限的负 number 处理 Infinity 呢？-0。</li></ul></li><li>零： JavaScript 拥有普通的零 0（也称为正零 +0） 和 一个负零 -0<ul><li>将一个负零转换为字符串，它将总会被报告为 “0”。有趣的是，反向操作（从 string 到 number），会得到-0。</li><li>-0 === 0; // true。</li><li>如果你想在你的代码中区分 -0 和 0。isNegZero =&gt; (Number(n) === 0) &amp;&amp; (1 / Number(n) === -Infinity);</li><li>在这些应用程序中，举例来说，如果一个变量的值变成了 0，而它丢失了符号，那么你就丢失了它是从哪个方向移动到 0 的信息。保留零的符号避免了潜在的意外信息丢失。</li></ul></li></ul></li><li>特殊等价：在 ES6 中，有一个新工具可以用于测试两个值的绝对等价性，而没有任何这些例外。它称为 Object.is(..)<ul><li>Object.is(..) 很大程度上是为这些(0, -0, NaN)特殊的等价情况准备的。</li></ul></li><li>值与引用：值的 类型 用来 唯一 控制值是通过值拷贝，还是引用拷贝来赋予。<ul><li>简单值（也叫基本标量）：总是 通过值拷贝来赋予/传递：null、undefined、string、number、 boolean、以及 ES6 的 symbol。</li><li>复合值：总是 在赋值或传递时创建一个引用的拷贝：Object、Array、Function。</li></ul></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/ch5.md" target="_blank" rel="noopener">第五章：文法</a></p></blockquote><ul><li>语句完成值：把语句敲进你的浏览器开发者控制台，因为当你运行它时，默认地控制台会报告最近一次执行的语句的完成值。<ul><li>var语句本身给出的结果是undefined。为什么？因为在语言规范中var语句就是这么定义的。</li><li>有一个称为“do表达式”的ES7提案。</li></ul></li><li>表达式副作用：大部分表达式没有副作用，以下除外<ul><li><code>++</code>,<code>--</code>：当++像++a这样用于前缀位置时，它的副作用（递增a）发生在值从表达式中返回 之前，而不是a++那样发生在 之后。</li><li>delete：如果被请求的操作是合法/可允许的，delete操作符的结果值为true，否则结果为false。但是这个操作符的副作用是它移除了属性（或数组值槽）。</li><li>a = b = c = 42：c = 42被求值得出42（带有将42赋值给c的副作用），然后b = 42被求值得出42（带有将42赋值给b的副作用），而最后a = 42被求值（带有将42赋值给a的副作用）。</li></ul></li><li>上下文规则：<ul><li>{ .. } 大括号：<ul><li>对象字面量：<ul><li>实际上完全合法的JSON值{“a”:42}本身将会抛出一个JS错误，因为它被翻译为一个带有非法标签的语句块儿。</li><li>JSON-P使JSON成为合法的JS文法！</li></ul></li><li>break/continue：<ul><li>一个标签也可以用于一个非循环的块儿，但只有break可以引用这样的非循环标签。</li><li>你可以使用带标签的break <strong>_跳出任何被标记的块儿，但你不能continue _</strong>一个非循环标签，也不能用一个不带标签的break跳出一个块儿。</li></ul></li></ul></li></ul></li><li>else if 和可选块儿：JS文法隐藏的性质：它没有else if。但是如果附着在if和else语句后面的代码块儿仅包含一个语句时，if和else语句允许省略这些代码块儿周围的{ }。</li><li>操作符优先级：<code>&amp;&amp;</code> &gt; <code>||</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算符优先级</a></li><li>自动分号：ASI（Automatic Semicolon Insertion —— 自动分号插入），仅在一个语句和这一行的换行之间除了空格和/或注释没有别的东西时。</li><li>try…finally：一般来说，在函数中省略return和return;或者return undefined;是相同的，但是在一个finally块儿内部，return的省略不是用一个return undefined覆盖；它只是让前一个return继续生效。</li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/types%20&%20grammar/apA.md" target="_blank" rel="noopener">附录A：与环境混合的JavaScript</a></p></blockquote><ul><li>在字符串字面量（不是一个字符串变量）中允许出现的最大字符个数</li><li>在一个函数调用的参数值中可以发送的数据的大小（字节数，也称为栈的大小）</li><li>在一个函数声明中的参数数量</li><li>没有经过优化的调用栈最大深度（比如，使用递归时）：从一个函数到另一个函数的调用链能有多长</li><li>JS程序可以持续运行并阻塞浏览器的秒数</li><li>变量名的最大长度</li><li>…</li></ul><hr><h3 id="你不懂JS-异步与性能"><a href="#你不懂JS-异步与性能" class="headerlink" title="你不懂JS: 异步与性能"></a><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&%20performance/README.md#you-dont-know-js-async--performance" target="_blank" rel="noopener">你不懂JS: 异步与性能</a></h3><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&%20performance/ch1.md" target="_blank" rel="noopener">第一章: 异步: 现在与稍后</a></p></blockquote><ul><li>块儿（Chunks）中的程序：每当你将一部分代码包进function并且规定它应当为了响应某些事件而执行（定时器，鼠标点击，Ajax应答等等），你就创建了一个 稍后 代码块儿，也因此在你的程序中引入了异步。</li><li>异步控制台：<ul><li>关于console.*方法如何工作，没有相应的语言规范或一组需求——它们不是JavaScript官方的一部分，而是由 宿主环境 添加到JS上的</li><li>到底在什么条件下consoleI/O将被推迟是不确定的，甚至它能不能被观察到都是不确定的。只能当你在调试过程中遇到问题时——对象在console.log(..)语句之后被修改，但你却意外地看到了修改后的内容——意识到I/O的这种可能的异步性。</li></ul></li><li>事件轮询：尽管明确地允许异步JS代码（就像我们刚看到的超时），但是实际上，直到最近（ES6）为止，JavaScript本身从来没有任何内建的异步概念。<ul><li>在每次调用JS引擎时，可以 随着时间的推移 执行你的程序的多个代码块儿，这称为“事件轮询（Event Loop）”。</li><li>你的程序通常被打断成许多小的代码块儿，它们一个接一个地在事件轮询队列中执行。而且从技术上说，其他与你的程序没有直接关系的事件也可以穿插在队列中。</li></ul></li><li>Jobs：在ES6中，在事件轮询队列之上引入了一层新概念，称为“工作队列（Job queue）”。你最有可能接触它的地方是在Promises。</li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&%20performance/ch2.md" target="_blank" rel="noopener">第二章: 回调</a></p></blockquote><ul><li><strong>本章是故事叙述，主要讲解决回调的一些过渡手段</strong></li></ul><blockquote><p><a href="https://github.com/jackyleungcn/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&%20performance/ch3.md" target="_blank" rel="noopener">第三章: Promises</a></p></blockquote><ul><li>Promise值：<ul><li>Promise包装了时间相关的状态——等待当前值的完成或拒绝——从外部看来，Promise本身是时间无关的，如此Promise就可以用可预测的方式组合，而不用关心时间或底层的结果。</li><li>一旦Promise被解析，它就永远保持那个状态——它在那个时刻变成了一个 不可变的值。</li><li>Promise是一种用来包装与组合 未来值，并且可以很容易复用的机制。</li></ul></li><li>Promise“事件”：<ul><li>then(..)注册了”fulfillment（完成）”和/或”rejection（拒绝）”事件</li><li>就是Promise（一旦被解析）会永远保持相同的解析结果（完成或拒绝），而且可以按需要后续地被监听任意多次。</li></ul></li><li>Thenable鸭子类型：根据值的形状（存在什么属性）来推测它的“类型”的“类型检查”有一个一般的名称，称为“鸭子类型检查”——“如果它看起来像一只鸭子，并且叫起来像一只鸭子，那么它一定是一只鸭子”<ul><li>识别一个Promise（或像Promise一样动作的某些东西）的方法是定义一种称为“thenable”的东西，也就是任何拥有then(..)方法的对象或函数。这种方法假定任何这样的值都是一个符合Promise的thenable。</li><li>无论是过去，现在，还是将来，可以拥有then(..)函数，不管是有意的还是偶然的，否则这个值将在Promise系统中被混淆为一个thenable，从而可能产生非常难以追踪的Bug。</li></ul></li><li>信任建立：Promise是一个用可靠语义来增强回调的模式，所以它的行为更合理更可靠。通过将回调的 控制倒转 反置过来，我们将控制交给一个可靠的系统（Promise），它是为了将你的异步处理进行清晰的表达而特意设计的。</li><li>链式流程：可以将多个Promise串联在一起来表达一系列的异步步骤。<ul><li>在一个Promise上的then(..)调用会自动生成一个新的Promise并返回。</li><li>在完成/拒绝处理器内部，如果你返回一个值或抛出一个异常，新返回的Promise（可以被链接的）将会相应地被解析。</li><li>如果完成或拒绝处理器返回一个Promise，它会被展开，所以无论它被解析为什么值，这个值都将变成从当前的then(..)返回的被链接的Promise的解析。</li></ul></li><li>错误处理：<ul><li>为了回避把一个被遗忘/抛弃的Promise的错误无声地丢失，一些开发者宣称Promise链的“最佳实践”是，总是将你的链条以catch(..)终结。</li></ul></li></ul><blockquote><p>未完待续…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文作为阅读【你不懂JS（You-Dont-Know-JS）】系列丛书的笔记总结，持续更新内容。旨在每章的关键概念，方便日后翻查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;你不懂JS：作用域与闭包&quot;&gt;&lt;a href=&quot;#你不懂JS：作用
      
    
    </summary>
    
      <category term="读书" scheme="http://www.liangjunqi.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="Javascript" scheme="http://www.liangjunqi.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Git合作模式</title>
    <link href="http://www.liangjunqi.com/2018/06/24/Git%E5%90%88%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.liangjunqi.com/2018/06/24/Git合作模式/</id>
    <published>2018-06-24T11:46:31.000Z</published>
    <updated>2019-08-28T09:57:37.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT分支模型"><a href="#GIT分支模型" class="headerlink" title="GIT分支模型"></a><strong>GIT分支模型</strong></h1><p><img src="git-branch-manage.png" alt="GIT分支模型"></p><hr><h1 id="GIT-COMMIT规范"><a href="#GIT-COMMIT规范" class="headerlink" title="GIT COMMIT规范"></a><strong>GIT COMMIT规范</strong></h1><ol><li>head: type(scope): subject<ul><li>type 类型<ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>optimize：优化</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>publish 发布</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul></li><li>scope 修改范围（可选）<ul><li>主要是这次修改涉及到的部分，最好简单的概括</li></ul></li><li>subject 修改的副标题<ul><li>主要是具体修改的加点</li></ul></li></ul></li><li>body（可选，建议72个字符以内）<ul><li>修改的主体标注</li></ul></li><li>footer（可选）<ul><li>主要放置不兼容变更</li><li>Issue关闭的信息</li></ul></li></ol><h4 id="Commit示例："><a href="#Commit示例：" class="headerlink" title="Commit示例："></a><strong>Commit示例：</strong></h4><p><img src="git-commit.png" alt="Commit示例"></p><h4 id><a href="#" class="headerlink" title=" "></a> </h4><hr><h2 id="GIT-Merge-Request规范"><a href="#GIT-Merge-Request规范" class="headerlink" title="GIT Merge Request规范"></a><strong>GIT Merge Request规范</strong></h2><p><img src="git-merge-request.png" alt="GIT Merge Request规范"></p><p><strong>Merge Request至少包含3要素</strong></p><p><strong>1、标题</strong>，[功能名，BUG修复，Core Review修复…]</p><p><strong>2、内容</strong>，[功能任务链接，说明…]</p><p><strong>3、标签</strong>，根据内容选择合适的标签，若无可创建新标签，以便追溯历史纪录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GIT分支模型&quot;&gt;&lt;a href=&quot;#GIT分支模型&quot; class=&quot;headerlink&quot; title=&quot;GIT分支模型&quot;&gt;&lt;/a&gt;&lt;strong&gt;GIT分支模型&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;git-branch-manage.png&quot; 
      
    
    </summary>
    
      <category term="管理" scheme="http://www.liangjunqi.com/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Git" scheme="http://www.liangjunqi.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Object(key/value)默认值与服务端交互</title>
    <link href="http://www.liangjunqi.com/2018/05/23/Object(key-value)%E9%BB%98%E8%AE%A4%E5%80%BC%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.liangjunqi.com/2018/05/23/Object(key-value)默认值与服务端交互/</id>
    <published>2018-05-23T07:12:54.000Z</published>
    <updated>2019-08-29T06:12:15.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：在与服务器交互中，发送/接收的数据有误。有服务端同事反映在部分业务上发现太多如undefined、null之类的传值。鉴于此有了这篇文档，望前端er在日常开发中，避免出现这种数据上的传输错误。虽然看起来是小事，但是在特定的业务上，引发的不仅是服务端抛异常，更严重者会造成生产环境下的损失，如收集表单数据。项目直接导致公司损失。</p></blockquote><h3 id="数据交互表格"><a href="#数据交互表格" class="headerlink" title="数据交互表格"></a>数据交互表格</h3><table><thead><tr><th>客户端发送</th><th>服务端接收</th><th>服务端返回</th><th>客户端赋值</th></tr></thead><tbody><tr><td>“”（空字符串）</td><td>“”</td><td>“”</td><td>“”</td></tr><tr><td>null</td><td>(null)</td><td>字段缺省</td><td>undefined（嵌套对象会抛异常）</td></tr><tr><td>“null”</td><td>“null”</td><td>“null”</td><td>“null”</td></tr><tr><td>对象属性缺省 / undefined</td><td>字段缺省</td><td>字段缺省</td><td>undefined（嵌套对象会抛异常）</td></tr><tr><td>对象属性缺省 / undefined，String()转换成字符串</td><td>“undefined”（若字段为数字类型，服务端Gson解析会报错）</td><td>“undefined”</td><td>“undefined”</td></tr></tbody></table><br><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><table><thead><tr><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>String</td><td>“”</td></tr><tr><td>Number</td><td>0（按实际情况而定）</td></tr><tr><td>Array</td><td>[]</td></tr><tr><td>Object</td><td>{}</td></tr><tr><td>Boolean</td><td>true/false</td></tr></tbody></table><p><strong>如无必要，默认值不要出现null、undefined这两种数据类型。（特殊情况除外，如部分第三方组件调用之类）</strong></p><br><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol><li>使用正确的默认值，如表2所示。</li><li>在接收数据时，服务器常见是字段缺省，直接赋值会导致出现undefined。若获取嵌套对象的属性值，则会抛Cannot read property ‘key’ of undefined，可跟服务端沟通字段设置默认值。若嵌套过深，前端做好取值判断。</li><li>在发送/接收数据时，遵循文档的数据类型，特别是Number和String的区分。</li><li>在发送数据时，必须避免undefined、”undefined”、null、”null”这4种数据。对象属性值为undefined时，stringify会忽略该属性。对象属性值为null时，不可避免会出现null、”null”，提交前要做好判断。</li></ol><img src="object-stringify.png" alt="JSON.stringify结果" style="display: block; margin: 0 auto;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：在与服务器交互中，发送/接收的数据有误。有服务端同事反映在部分业务上发现太多如undefined、null之类的传值。鉴于此有了这篇文档，望前端er在日常开发中，避免出现这种数据上的传输错误。虽然看起来是小事，但是在特定的业务上，引发的不仅是
      
    
    </summary>
    
      <category term="技术小记" scheme="http://www.liangjunqi.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://www.liangjunqi.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>PM2部署项目</title>
    <link href="http://www.liangjunqi.com/2016/06/07/PM2%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.liangjunqi.com/2016/06/07/PM2部署项目/</id>
    <published>2016-06-07T09:06:53.000Z</published>
    <updated>2019-08-29T05:59:37.792Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PM2-http-server-部署"><a href="#PM2-http-server-部署" class="headerlink" title="PM2 http-server 部署"></a>PM2 http-server 部署</h4><pre class=" language-shell"><code class="language-shell">1.cd到项目根目录2.which http-server 找到http-server模块路径3.pm2 start /usr/local/bin/http-server --name PM2_NAME -- -p PORT -d false（PS: pm2 start /usr/local/bin/http-server --name static-server -- -p 8080 -d false）</code></pre><h4 id="PM2-npm-部署"><a href="#PM2-npm-部署" class="headerlink" title="PM2 npm 部署"></a>PM2 npm 部署</h4><pre class=" language-shell"><code class="language-shell">pm2 start npm --name pm2_name -- start</code></pre><h4 id="PM2-常用命令"><a href="#PM2-常用命令" class="headerlink" title="PM2 常用命令"></a>PM2 常用命令</h4><pre class=" language-shell"><code class="language-shell">pm2 list //查看PM2项目列表pm2 start <app_name|id|'all'> //启动 全部/某个 项目pm2 stop <app_name|id|'all'> //停止 全部/某个 项目pm2 restart <app_name|id|'all'> //重启 全部/某个 项目pm2 delete <app_name|id|'all'> //删除 全部/某个 项目pm2 logs //查看全部项目日志pm2 logs <app_name|id> //查看某个项目日志pm2 save //保存当前项目列表配置pm2 resurrect //恢复项目列表，数据来自上一次pm2 save</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;PM2-http-server-部署&quot;&gt;&lt;a href=&quot;#PM2-http-server-部署&quot; class=&quot;headerlink&quot; title=&quot;PM2 http-server 部署&quot;&gt;&lt;/a&gt;PM2 http-server 部署&lt;/h4&gt;&lt;pre clas
      
    
    </summary>
    
      <category term="服务端" scheme="http://www.liangjunqi.com/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="Node.js" scheme="http://www.liangjunqi.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>ES6优化-尾递归</title>
    <link href="http://www.liangjunqi.com/2016/05/22/ES6%E4%BC%98%E5%8C%96-%E5%B0%BE%E9%80%92%E5%BD%92/"/>
    <id>http://www.liangjunqi.com/2016/05/22/ES6优化-尾递归/</id>
    <published>2016-05-22T13:24:06.000Z</published>
    <updated>2019-08-29T06:32:00.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意：ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p></blockquote><h2 id="普通递归"><a href="#普通递归" class="headerlink" title="普通递归"></a>普通递归</h2><p>普通递归时，内存需要记录调用的堆栈所出的深度和位置信息。在最底层计算返回值，再根据记录的信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层的调用函数。在cpu计算和内存会消耗很多，而且当深度过大时，会出现堆栈溢出。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token operator">--</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*sum(5)(5 + sum(4))(5 + (4 + sum(3)))(5 + (4 + (3 + sum(2))))(5 + (4 + (3 + (2 + sum(1)))))(5 + (4 + (3 + (2 + 1))))(5 + (4 + (3 + 3)))(5 + (4 + 6))(5 + 10)15*/</span></code></pre><p>在计算的过程中，堆栈一直不停的记录每一层次的详细信息，以确保该层次的操作完成，能返回到上一层次。通过尾递归，可以取消过多的堆栈记录，而只记录最外层和当前层的信息，完成计算后，立刻返回到最上层。从而减少 cpu 计算和内存消耗。</p><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> total<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">+</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token operator">--</span>x<span class="token punctuation">,</span> x <span class="token operator">+</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*sum(5, 0)sum(4, 5)sum(3, 9)sum(2, 12)sum(1, 14)15*/</span></code></pre><pre><code>这个函数更具有数学描述性：如果输入值是1 =&gt; 当前计算数1 + 上一次计算的和total如果输入值是x =&gt; 当前计算数x + 上一次计算的和total</code></pre><p>整个计算过程是线性的，调用一次 sum(x, total) 后，会进入下一个栈，相关的数据信息和跟随进入，不再放在堆栈上保存。当计算完最后的值之后，直接返回到最上层的 sum(5,0)。这能有效的防止堆栈溢出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>使用尾递归可以带来一个好处：因为进入最后一步后不再需要参考外层函数（caller）的信息，因此没必要保存外层函数的stack，递归需要用的stack只有目前这层函数的，因此避免了栈溢出风险。</li><li>尾递归优化主要是对栈内存空间的优化, 这个优化是O ( n ) 到O ( 1 ) 的; 至于时间的优化, 其实是由于对空间的优化导致内存分配的工作减少所产生的, 是一个常数优化, 不会带来质的变化。</li><li>尾递归形式和循环(或者说“迭代”)形式大致就是同一个逻辑的两种表达形式而已。经过尾递归优化的尾递归代码和循环的代码的执行效率基本上是相当的. 这也是函数式编程效率上没有落后的一个很重要的原因。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;注意：ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;普通递归&quot;&gt;&lt;a href=&quot;#普通递归&quot; class=&quot;headerlink&quot; title=&quot;普通递归&quot;&gt;&lt;/a&gt;普通递归&lt;/h
      
    
    </summary>
    
      <category term="技术小记" scheme="http://www.liangjunqi.com/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://www.liangjunqi.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>一年前的一条微博</title>
    <link href="http://www.liangjunqi.com/2014/04/08/%E4%B8%80%E5%B9%B4%E5%89%8D%E7%9A%84%E4%B8%80%E6%9D%A1%E5%BE%AE%E5%8D%9A/"/>
    <id>http://www.liangjunqi.com/2014/04/08/一年前的一条微博/</id>
    <published>2014-04-08T10:00:00.000Z</published>
    <updated>2019-08-28T09:57:22.349Z</updated>
    
    <content type="html"><![CDATA[<img src="weibo-front-msg.png" style="margin: 0 auto; display: block;"><br><p style="text-align: right">也不知道错对，当时满怀激情的憧憬。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;weibo-front-msg.png&quot; style=&quot;margin: 0 auto; display: block;&quot;&gt;

&lt;br&gt;

&lt;p style=&quot;text-align: right&quot;&gt;也不知道错对，当时满怀激情的憧憬。&lt;/p&gt;
      
    
    </summary>
    
      <category term="日记" scheme="http://www.liangjunqi.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="个人感想" scheme="http://www.liangjunqi.com/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
</feed>
